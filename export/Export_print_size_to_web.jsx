////////////////////////////////////////////////////////////////// // TWP to WPNI web graphic conversion script// part 1: write eps out for CCI// part 2: setCropBox// part 3: determine scaling factor for web column sizes// part 4: write out GIF or JPG for Orbit WPNI// snippits from "SetCropBoxToSelection.jsx" scripted by Rassadin Pavel (RPV); e-mail: mf36@yandex.ru; data of modifying: 11.05.2006; freeware; // snippits from TileWrapper -- CS, // JS code (c) copyright: John Wundes ( john@wundes.com ) www.wundes.com ... copyright full text here:  http://www.wundes.com/js4ai/copyright.txt// snippits from  Sâ€¡ndor Milos forum@siscosep.com from http://www.siscosep.com/ftp/forum/skripten/illustrator/OpenAiUndEpsSaveEPS.js// snippits from Wolfgang Reszel (ai-js@rumborak.de) from http://illustrator.hilfdirselbst.ch/dokuwiki/_media/english/scripts/javascript/wolfgangreszel/wr-dateandtime.js?id=en%3Askripte%3Ajavascript%3Awr-dateandtime&cache=cache// snippits from Illustrator CS3 Javascript Reference////////////////////////////////////////////////////////////////// // TODO: Dec 11 2007 :: Add toggle to ignore items past the page boundary//            This would somewhat fix if someone has not deleted the template items on the left of the page?// File type to export// This should be judged on type of items in the file when setCropArea is evaluatedvar f_ext = "jpg";var dest="C:\\Temp";var Dateformat = "mmddyy";var widthFuzzy = new Number(1.10); 		// if the art is just over the size for that column, then treat as smaller columnvar doc = app.activeDocument;var obj = doc.pageItems;var bnd = new Array();var scale2WPNI = new Number;scale2WPNI = 172.5;// Determine the content area, set crop to content// setCropArea();// Remember the existing crop settings so we can return to themtry{	if( doc.cropBox[0] == null || doc.cropBox[0] >= 10000 ) {		theNullBox = new Array( 16383, 16383, 16383, 16383 );		var cropOLD = theNullBox;		// Determine the content area, set crop to content		setCropArea();	} else {		var cropOLD = doc.cropBox;		bnd[0] =  doc.cropBox[0];		bnd[2] =  doc.cropBox[2];	}} catch (e) {	theNullBox = new Array( 16383, 16383, 16383, 16383 );	doc.cropBox = theNullBox;	var cropOLD = doc.cropBox;		// Determine the content area, set crop to content	setCropArea();}// Determine where to save the file and what name to give it (eg: "myStorySlug_mmddyy" with .jpg or .gif or .eps as specified)dest = setFileName();//exportFileToEPS();// Determine the content / crop widthcontentWidth = bnd[2] - bnd[0];//prompt(contentWidth);// Determine what WPNI column size it should be scaled up to (sets scale2WPNI variable)setScalingWPNI( contentWidth );doTheSave();function doTheSave() {	// if there is a gradient or image in the file, then JPG	// else GIF	// So when checking the bounding box, also check the object type	// and if gradient or image then set fileTypeJPG = true and use that on the writeout?	//---------------------	// If nothing is selected, 	// then it is assumed that you want to save the image	//----------------------		// ---------------This is the saving part. 		//--------Comment it out if you don't want to save.		// Which OS are we on? 				/*		while(f_ext!="gif" && f_ext!="jpg" && f_ext!="png" && f_ext!="eps"){				dest = File.saveDialog("Export Image as *gif or *.jpg or *.png or *.eps:", "GIF image: *.gif, JPG image:*.jpg,Transparent PNG image:*.png, EPS vector file: *.eps");				  f_ext = dest.toString().split(".")[1].toLowerCase();				if(f_ext!="gif" && f_ext!="jpg" && f_ext!="png" && f_ext!="eps"){					alert("Please include the dot extension ('.gif or .jpg' or '.png' or '.eps')of the desired filetype.");				}			}			if(dest!="" && dest!= null){	*/	// Set the final file name with type extension	dest = dest + "." + f_ext;		if( f_ext == "gif"){		exportFileToGIF (dest);	} else if( f_ext == "jpg"){			exportFileToJPEG (dest);	} else if(f_ext == "png"){			exportFileToPNG24 (dest);	} else if(f_ext == "eps"){			exportFileToEPS (dest);	} else {		alert("Save cancelled");	}		//------------------------------end saving part.}// reset the crop box to whatever it was beforedoc.cropBox = cropOLD;function setCropArea() {	if (documents.length > 0){			if (doc.layers.length > 0) {			totalLayers = doc.layers.length;						// initilize the boundary			bnd[0] = null;			bnd[2] = null;			bnd[1] = null;			bnd[3] = null;						var firstTime = true;			// now get the boundary for each layer			for( layerCounter = totalLayers-1; layerCounter >= 0;  layerCounter-- ) {					isVisibleLayer = doc.layers[ layerCounter ].visible;				thisLayersObjects = doc.layers[ layerCounter ].pageItems;				// the layer has to be visible and have contents... and the patches layer should be ignored (often extra patches are outside the neatline)				// Problem with type on a path where the path bounds is being reported... even if it goes beyond the neatline and has no path right on it (the type is inside the neatline)				// Or test for path type and if not stroked then ignore?				// This way point and area type would still be counted, even on the type map layer				// Would need to be done in the GetBounds function				// Also need to discount graph type objects since they often fall outside in invisible pieces				if( (isVisibleLayer && thisLayersObjects.length > 0) && (doc.layers[ layerCounter ].name != "Patches") && (doc.layers[ layerCounter ].name != "Type map") ) {					layer_bnd = getBounds(thisLayersObjects);							if( firstTime ) {						// prompt( "first time" );						bnd[0] = layer_bnd[0];						bnd[1] = layer_bnd[1];						bnd[2] = layer_bnd[2];						bnd[3] = layer_bnd[3];						firstTime = false;					} else {						// prompt( "nth time" );						// sprompt( layer_bnd[0], layer_bnd[2], layer_bnd[3] );						if( bnd[0] > layer_bnd[0] ) bnd[0] = layer_bnd[0];						if( bnd[1] < layer_bnd[1] ) bnd[1] = layer_bnd[1];						if( bnd[2] < layer_bnd[2] ) bnd[2] = layer_bnd[2];						if( bnd[3] > layer_bnd[3] ) bnd[3] = layer_bnd[3];						// prompt( bnd[0], bnd[2], bnd[3] );					}				}			}			// prompt( bnd[0], bnd[1], bnd[2] );			W = bnd[2] - bnd[0];			H = bnd[1] - bnd[3];			X = bnd[0];			Y = bnd[1];		// if there is no layers? shouldn't it be objects on that layer?		} else {			doc.rulerOrigin = Array(0, 0);			bnd[0] = 0;			bnd[2] = doc.width;			bnd[1] = doc.height;			bnd[3] = 0;				}			// prompt( bnd[0], bnd[1], bnd[2] );		doc.cropBox = bnd;		doc.cropStyle = CropOptions.Standard;		}}function setScalingWPNI( theContentWidth ) {	if( theContentWidth ) {		scale2WPNI = 1.70;								    	// default else state for larger graphics				// assume 1 web column to begin with				if( theContentWidth < 132 * widthFuzzy ) {		// if 1 columns (			  scale2WPNI = 228 / theContentWidth;		// should be about 172.0;		}		if( theContentWidth >= 132 * widthFuzzy) {		// if 2 columns			  scale2WPNI = 454 / theContentWidth;		// should be about 163.0;		}		if( theContentWidth >= 278 * widthFuzzy) {		// if 3 columns			  scale2WPNI = 624 / theContentWidth;		// should be about 147.0;		}		if( theContentWidth >= 424 * widthFuzzy) {		// if 4 columns			  scale2WPNI = 970 / theContentWidth;		// should be about 170.0;		} 		if( theContentWidth >= 570 * widthFuzzy) {		// if 5 columns and UP			  scale2WPNI = 1.70;									// should be about 170.0;		} 		// now scale back to whole number instead of decimal		scale2WPNI *= 100;		// make sure we're UNDER and not OVER the web column size (should only be a pixel or two difference)		scale2WPNI = Math.floor( scale2WPNI );		if( scale2WPNI < 100 ) {				scale2WPNI = 170;		}	} else {		scale2WPNI = 170;	}}function getBounds(obj) {	var selObj1 = new Array();	var selObj2 = new Array();	var vgb1 = new Array();	var vgb2 = new Array();	var n = obj.length;		if (n>0){					// ignore worst case of (1) type on path or (2) guide items		if( (obj[0].guides == true) ){			// do nothing		} else {			// group items that are masked case			if( (obj[0].typename == 'GroupItem') && obj[0].clipped && (obj[0].pageItems.length > 1) ){				clipObj = obj[0].pathItems[0].geometricBounds;				vgb1 = clipObj;			} else {				selObj1 = obj[0];				vgb1 = selObj1.visibleBounds;			}/*		} else {			vgb1 = new Array;			vgb1[0] = vgb1[1] = vgb1[2] = vgb1[3] = null;*/		}				// loose page items case		if (n > 1) {			for (i=1; i<n; i++) {				selObj2 = obj[i];								// do a test here for the path type (ignore it, break to next object)				/*if( (obj[i].guides) ){					continue; 				}*/												// do a test here for the guides type (ignore it, break to next object)				if( (obj[i].guides == true) ){					// do nothing				} else {					// layer clipping mask case					if( (obj[i].typename == 'PathItem') && (obj[i].clipping) ){						clipObj = obj[i].geometricBounds;						vgb2 = clipObj;						return vgb2;					}														if( (obj[i].typename == 'GroupItem') && obj[i].clipped && (obj[i].pageItems.length > 1) ) {						vgb2 = obj[i].pathItems[0].geometricBounds;					} else {						vgb2 = selObj2.visibleBounds;					}					if( vgb1[0] > vgb2[0] ) vgb1[0] = vgb2[0];					if( vgb1[1] < vgb2[1] ) vgb1[1] = vgb2[1];					if( vgb1[2] < vgb2[2] ) vgb1[2] = vgb2[2];					if( vgb1[3] > vgb2[3] ) vgb1[3] = vgb2[3];				}			}		}	}	return vgb1;}//------------------------//-------- Saving functions: Change line 98 to save as PNG instead...//------------------------function exportFileToEPS (dest) {	if ( app.documents.length > 0 ) {		var saveOptions = new EPSSaveOptions();		var type = ExportType.JPEG;		var fileSpec = new File(dest);		//Speichern optionen		saveOptions.cmykPostScript = true;		//8 bit Tiff vorschau 		saveOptions.preview = EPSPreview.COLORTIFF;		//Postscript Level 2		saveOptions.postScript = EPSPostScriptLevelEnum.LEVEL2;		//Compatibility with CS2		saveOptions.compatibility = Compatibility.ILLUSTRATOR12;		// Embede the fonts so they rip in web tracker		saveOptions.embedAllFonts = true;		// Now actually save the EPS out		app.activeDocument.saveAs( fileSpec, saveOptions );	}}function exportFileToGIF (dest) {	if ( app.documents.length > 0 ) {		var exportOptions = new ExportOptionsGIF();		var type = ExportType.GIF;		var fileSpec = new File(dest);		exportOptions.antiAliasing = true;		exportOptions.colorDither = ColorDitherMethod.NOREDUCTION;		exportOptions.colorReduction = ColorReductionMethod.SELECTIVE;		exportOptions.transparency = false;			exportOptions.interlaced = false;		exportOptions.webSnap = 0;		exportOptions.horizontalScale = scale2WPNI;		exportOptions.verticalScale = scale2WPNI;		//exportOptions.saveAsHTML = true;		// Set to false for CS and CS2		// exportOptions.matte = true;		// ---- This code is commented out because white is the default color		// ==== but if you want a custom matte, you can reinstate it.		//var newRGBColor = new RGBColor();		//newRGBColor.red = 255;		//newRGBColor.green = 255;		//newRGBColor.blue = 255;		//exportOptions.matteColor=newRGBColor;		app.activeDocument.exportFile( fileSpec, type, exportOptions );	}}function exportFileToJPEG (dest) {	if ( app.documents.length > 0 ) {		var exportOptions = new ExportOptionsJPEG();		var type = ExportType.JPEG;		var fileSpec = new File(dest);		exportOptions.antiAliasing = true;		exportOptions.qualitySetting = 70;		exportOptions.horizontalScale = scale2WPNI;		exportOptions.verticalScale = scale2WPNI;				// Set to false for CS and CS2		exportOptions.matte = true;		// ---- This code is commented out because white is the default color		// ==== but if you want a custom matte, you can reinstate it.		//var newRGBColor = new RGBColor();		//newRGBColor.red = 255;		//newRGBColor.green = 255;		//newRGBColor.blue = 255;		//exportOptions.matteColor=newRGBColor;		app.activeDocument.exportFile( fileSpec, type, exportOptions );	}}function exportFileToPNG24 (dest) {	if ( app.documents.length > 0 ) {		var exportOptions = new ExportOptionsPNG24();		var type = ExportType.PNG24;		var fileSpec = new File(dest);		exportOptions.antiAliasing = true;		exportOptions.transparency = false;		exportOptions.horizontalScale = scale2WPNI;		exportOptions.verticalScale = scale2WPNI;				//exportOptions.saveAsHTML = true;		app.activeDocument.exportFile( fileSpec, type, exportOptions );	}}function setFileName() {	// var format_preset = "{FILENAME} ({DATE} - {TIME})";	// var Dateformat = "mm.dd.yy";	// var Dateformat = "mm/dd/yy";	// var Dateformat = "mmddyy";		var error=0;	if (documents.length<1) {	  error++;	  alert("Open a document and then run this script.")	}	if (error < 1) {	  var fileName = new String; 	  fileName = FileName_Date();	  return fileName;	}}// TODO: Pick up here// TODO: Still need to determine the full path for setting the File object parameter// TODO: auto default to JPG if there is a gradient or image// TODO: else default to GIF// TODO: appned the appropriate extention and run the appropriate function to output graphic// TODO: append EPS and run that function before the image export//var temp111 = setFileName();//prompt( temp111 );function FileName_Date() {  // var docpath = activeDocument.path.fsName;  // var docname = activeDocument.name;  // var content = format.replace(/\{FILENAME\}/,docname);  // var content = format.replace(/\{DATE\}/,PuplicationDate());	  var theDocName = activeDocument.name;  var theDocPath = activeDocument.path;  var theFileExtIndex = theDocName.lastIndexOf(".")  theDocName = theDocName.substr( 0, theFileExtIndex );  theDocName = theDocPath + "/" + theDocName + "_" + PuplicationDate();  return theDocName;}// Warning!!! Does NOT return todays date unless early AM hours of today// Returns TOMORROWs datefunction PuplicationDate() {  var Today = new Date();  var Day = Today.getDate();  var Month = Today.getMonth() + 1;  var Year = Today.getYear();  // var Year = Today.getYear() + 1900;  // var PreYear = ((Year < 10) ? "0" : "");  var PreMon = ((Month < 10) ? "0" : "");  var PreDay = ((Day < 10) ? "0" : "");  if(Year < 999) Year += 2000;	// what if it's in the early AM hours of the pub day?	// Then it should be the same day, not next day	var Hours = Today.getHours();	if( Hours > 5 ) {		Day++;	}	var theDate = Dateformat.replace(/dd/,PreDay+Day);	theDate = theDate.replace(/mm/,PreMon+Month);	theDate = theDate.replace(/d/,Day);	theDate = theDate.replace(/m/,Month);	theDate = theDate.replace(/yyyy/,Year);	theDate = theDate.replace(/yy/,Year.toString().substr(2,2));	return theDate;}