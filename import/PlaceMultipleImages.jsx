// Import Folder's Files as Layers - Illustrator CS3 script// Description: Imports a series of images (from the designated folder) as named layers into a new document// Allows individual images or folders of images to be scaled on placement via a %xx% in the file and/or folder name.// Allows for // Author: Nathaniel V. KELSO (nathaniel@kelsocartography.com)// • Artboards for new tiled artwork// Version: 1.2.0 on 23/March/2009// • Tile placed artwork via grid// • Name placed artwork object from original file name (not just the layer anymore)// Version: 1.1.0 on 20/March/2009// • Allow placed artwork scaling via layer or file names// • Allow embedding of placed artwork. Helpful when exporting file to image format as Illustrator would otherwise use the low-resolution EPS preview. // Version: 1.0.0 on 10/March/2009// • Basic functionality// USER DEFINED AND MODIFIABLE// GLOBAL SCRIPT SETTINGS// var queryMethod = "selection";var queryMethod = "selectionOrAnywhere";//var queryMethod = "current artboard";//var queryMethod = "any artboard";//var queryMethod = "anywhere";var placement9pointAlignment = "mm";var allowPlacedArtworkScaling = true;var embedPlacedEPSartwork = true;var distributeMethod = "grid";//var distributeMethod = "row";//var distributeMethod = "column";var distributeBias = "each";//var distributeBias = "first-strict";//var distributeBias = "first-minimum";//var distributeBias = "manual-strict";//var distributeBias = "manual-minimum";//var distributeBias = "largest";var topHeavy = true;var leftHeavy = true;var sortOnAttribute = "height";var distributeCompact = true;var newLayerForEachPlacedItem = false;var gridSpacingColumn_manual = 100;var gridSpacingRow_manual = 100;var makeArtboardFromArtworkBounds = true;var makeArtboardUsingBias = true;// DO NOT MODIFY// INTERNAL APPLICATION VARIABLESvar scalePlacedArtworkViaLayer = false;var scaleFactorXYviaLayer = 100;var scalePlacedArtworkViaObject = false;var scaleFactorXYviaObject = 100;var examineRow = 0;var examineColumn = 0;function getFolder() {	return Folder.selectDialog('Please select the folder to be imported. Note you can put %150% in the folder name if you want all images in the folder to be scaled by 150%.', Folder('~'));}function distributeSpacing() {	var artworkToSort;	var trackingArray = [];	var gridSpacingArrayColumns = [];	var gridSpacingArrayRows = [];	var gridSpacingArrayColumnsXabs = [];	var gridSpacingArrayRowsYabs = [];		switch( queryMethod ) {		case "selection" :			artworkToSort = app.activeDocument.selection;			break;		case "selectionOrAnywhere" :			if( app.activeDocument.selection.length > 0 ) {				artworkToSort = app.activeDocument.selection;			} else {				artworkToSort = app.activeDocument.pageItems;			}			break;		case "anywhere" :		default : 			artworkToSort = app.activeDocument.pageItems;			break;		//	}		// Require certain settings based on other settings	if( distributeBias = "first" ) {		//distributeCompact = true;	}		// Artboards are not supported in earlier versions of Illustrator prior to and including CS3	if( makeArtboardFromArtworkBounds ) {		if( Number( app.version.substring( 0, app.version.indexOf('.') ) )  < 14 ) {			makeArtboardFromArtworkBounds = false;		}	}					for( var a = 0; a < artworkToSort.length; a++ ) {		trackingArray[a] = { index: a, width: artworkToSort[a].width, height: artworkToSort[a].height, 									 area: artworkToSort[a].area, 									 bounds: (artworkToSort[a].visibleBounds[1] - artworkToSort[a].visibleBounds[0] ) * (artworkToSort[a].visibleBounds[3] - artworkToSort[a].visibleBounds[2] ), 									 column: 1, row: 1 };	}					// Order the artwork by dimension	if( 	distributeBias != "first-strict" &&			distributeBias != "first-minimum" 	) {		switch( sortOnAttribute) {			case "width" :				trackingArray.sort( sortByWidth );				break;			case "height" :				trackingArray.sort( sortByHeight );				break;			case "area" :				trackingArray.sort( sortByArea );				break;			case "bounds" :				trackingArray.sort( sortByBounds );				break;			case "random" :				trackingArray.sort( sortByRandom );				break;			//		}		if( ! topHeavy ) {			trackingArray.reverse();		}	}		// Get the square root of the number of pageItems and then round that up to whole number	// This tell us how wide the grid of artwork will be.	var gridWidth = Math.ceil( Math.sqrt( artworkToSort.length ) );		var gridXorigin = 0;	var gridYorigin = app.activeDocument.height;						var gridXgap = 20;	var gridYgap = 20;		var gridRow = 1;	var gridColumn = 1;						var gridRowHeightTracker = 0;	var gridColumnWidthTracker = 0;		var thisArtwork;		// Gather spacing statistics	for( var j = 0; j < trackingArray.length; j++ ) {		thisArtwork = artworkToSort[ trackingArray[j].index ];				// If we've reached the end of the row		// Reset so next placedArt item is on new row down at left side		if( gridColumn > gridWidth ) {			// down one row			++gridRow;			// back to first column			gridColumn = 1;		}			// Store which row and column		trackingArray[j].row = gridRow;		trackingArray[j].column = gridColumn;										++gridColumn;	}	if( (topHeavy == false) && 		(leftHeavy == true) 	) {		for( var i = 0; i < gridWidth; i++ ) {			examineRow = i;					}	}	for( var i = 0; i < gridWidth; i++ ) {		gridSpacingArrayColumns[i] = 0;		gridSpacingArrayRows[i] = 0;	}			for( var i = 1; i < gridWidth; i++ ) {		for( var j = 0; j < trackingArray.length; j++ ) {			if( trackingArray[j].column == i ) {				thisArtwork = artworkToSort[ trackingArray[j].index ];				// Track overall width of column for next artwork placement				if( thisArtwork.width > gridSpacingArrayColumns[i] ) {					gridSpacingArrayColumns[i] = thisArtwork.width;				}			}			if( trackingArray[j].row == i ) {				thisArtwork = artworkToSort[ trackingArray[j].index ];				// Track overall height (depth) of row for next row placement				if( thisArtwork.height > gridSpacingArrayRows[i] ) {					gridSpacingArrayRows[i] = thisArtwork.height;				}			}		}	}	switch( distributeBias ) {		case "manual-minimum" :			// but use the first as MINIMUM size, not a strict size			var runningValue = gridXorigin;			for( var a = 0; a < gridSpacingArrayColumns.length; a++ ) {				if( gridSpacingArrayColumns[a] < gridSpacingColumn_manual ) {					runningValue += gridSpacingArrayColumns[0] + gridXgap + gridSpacingColumn_manual;				} else {					runningValue += gridSpacingArrayColumns[a] + gridXgap;				}				gridSpacingArrayColumnsXabs[a] = runningValue;			}			var runningValue = gridYorigin;			for( var a = 0; a < gridSpacingArrayRows.length; a++ ) {				if( gridSpacingArrayRows[a] < gridSpacingRow_manual ) {					runningValue -= gridSpacingArrayRows[0] + gridYgap + gridSpacingRow_manual;				} else {					runningValue -= gridSpacingArrayRows[a] + gridYgap;				}				gridSpacingArrayRowsYabs[a] = runningValue;			}			break;		case "manual-strict" :			// but use the first as MINIMUM size, not a strict size			var runningValue = gridXorigin;			for( var a = 0; a < gridSpacingArrayColumns.length; a++ ) {				runningValue += gridSpacingArrayColumns[0] + gridXgap + gridSpacingColumn_manual;				gridSpacingArrayColumnsXabs[a] = runningValue;			}			var runningValue = gridYorigin;			for( var a = 0; a < gridSpacingArrayRows.length; a++ ) {				runningValue -= gridSpacingArrayRows[0] + gridYgap + gridSpacingRow_manual;				gridSpacingArrayRowsYabs[a] = runningValue;			}			break;		case "first-minimum" :			// but use the first as MINIMUM size, not a strict size			var runningValue = gridXorigin;			for( var a = 0; a < gridSpacingArrayColumns.length; a++ ) {				if( gridSpacingArrayColumns[a] < gridSpacingArrayColumns[1] ) {					runningValue += gridSpacingArrayColumns[0] + gridXgap + gridSpacingArrayColumns[1];				} else {					runningValue += gridSpacingArrayColumns[a] + gridXgap;				}				gridSpacingArrayColumnsXabs[a] = runningValue;			}			var runningValue = gridYorigin;			for( var a = 0; a < gridSpacingArrayRows.length; a++ ) {				if( gridSpacingArrayRows[a] < gridSpacingArrayRows[1] ) {					runningValue -= gridSpacingArrayRows[0] + gridYgap + gridSpacingArrayRows[1];				} else {					runningValue -= gridSpacingArrayRows[a] + gridYgap;				}				gridSpacingArrayRowsYabs[a] = runningValue;			}			break;		case "first-strict" :			// but use the first as MINIMUM size, not a strict size			var runningValue = gridXorigin;			for( var a = 0; a < gridSpacingArrayColumns.length; a++ ) {				runningValue += gridSpacingArrayColumns[0] + gridXgap + gridSpacingArrayColumns[1];				gridSpacingArrayColumnsXabs[a] = runningValue;			}			var runningValue = gridYorigin;			for( var a = 0; a < gridSpacingArrayRows.length; a++ ) {				runningValue -= gridSpacingArrayRows[0] + gridYgap + gridSpacingArrayRows[1];				gridSpacingArrayRowsYabs[a] = runningValue;			}			break;		case "largest" :				var largestWidth = 0;			var largestHeight = 0;			for( var a = 0; a < gridSpacingArrayColumns.length; a++ ) {				if( largestWidth < gridSpacingArrayColumns[a] ) {					largestWidth = gridSpacingArrayColumns[a];				}			}			for( var a = 0; a < gridSpacingArrayRows.length; a++ ) {				if( largestHeight < gridSpacingArrayRows[a] ) {					largestHeight = gridSpacingArrayRows[a];				}			}			//			var runningValue = gridXorigin;			for( var a = 0; a < gridSpacingArrayColumns.length; a++ ) {				runningValue += largestWidth + gridXgap;				gridSpacingArrayColumnsXabs[a] = runningValue;			}			var runningValue = gridYorigin;			for( var a = 0; a < gridSpacingArrayRows.length; a++ ) {				runningValue -= largestHeight + gridYgap;				gridSpacingArrayRowsYabs[a] = runningValue;			}			break;		case "each" :		default :			var runningValue = gridXorigin;			for( var a = 0; a < gridSpacingArrayColumns.length; a++ ) {				runningValue += gridSpacingArrayColumns[a] + gridXgap;				gridSpacingArrayColumnsXabs[a] = runningValue;			}			var runningValue = gridYorigin;			for( var a = 0; a < gridSpacingArrayRows.length; a++ ) {				runningValue -= gridSpacingArrayRows[a] + gridYgap;				gridSpacingArrayRowsYabs[a] = runningValue;			}			break;		//	}		var gridRow = 1;	var gridColumn = 1;						var gridRowHeightTracker = 0;	var gridColumnWidthTracker = 0;		var gridX = 0;	var gridY = app.activeDocument.height;		if( queryMethod == "selection" || 		(queryMethod == "selectionOrAnywhere" && app.activeDocument.selection.length > 0 )	) {		gridX = artworkToSort[ trackingArray[0].index ].left;		gridY = artworkToSort[ trackingArray[0].index ].top;		for( var a = 0; a < artworkToSort.length; a++ ) {			if( gridX > artworkToSort[ trackingArray[a].index ].left ) {				gridX = artworkToSort[ trackingArray[a].index ].left;			}			if( gridY < artworkToSort[ trackingArray[a].index ].top ) {				gridY = artworkToSort[ trackingArray[a].index ].top;			}		}		gridXorigin = gridX;		gridYorigin = gridY;	}		// Go thru the artwork tree by the tracking array (which is sorted by dimension)	for( var a = 0; a < trackingArray.length; a++ ) {		thisArtwork = artworkToSort[ trackingArray[a].index ];				// If we've reached the end of the row		// Reset so next placedArt item is on new row down at left side		if( gridColumn > gridWidth ) {			gridX = gridXorigin;			if( distributeCompact ) { 				gridY -= gridSpacingArrayRows[gridRow] + gridXgap;			} else {				gridY -= gridRowHeightTracker + gridYgap;				gridRowHeightTracker = 0;			}			++gridRow;			gridColumn = 1;		}						if( ! distributeCompact ) {			// Track overall height (depth) of row for next row placement			if( thisArtwork.height > gridRowHeightTracker ) {				gridRowHeightTracker = thisArtwork.height;			}			// Track overall width of column for next artwork placement			if( thisArtwork.width > gridColumnWidthTracker ) {				gridColumnWidthTracker += thisArtwork.width + gridXgap;			}		}				if( distributeCompact ) {			thisArtwork.left = gridX;			thisArtwork.top = gridY;		} else {			thisArtwork.left = gridSpacingArrayColumnsXabs[ gridColumn - 1 ];			thisArtwork.top = gridSpacingArrayRowsYabs[ gridRow - 1 ];		}				if( makeArtboardFromArtworkBounds ) {			beep();			//if( makeArtboardUsingBias ) {							//} else {							//}		}				// Get ready for next time		if( distributeCompact ) {			gridX += thisArtwork.width + gridXgap;		}		++gridColumn;	}			var testingString = "a";	for( var a = 0; a < trackingArray.length; a++ ) {		testingString += "\t" + a;	}	testingString += "\rindex";	for( var a = 0; a < trackingArray.length; a++ ) {		testingString += "\t" + trackingArray[a].index;	}	testingString += "\rrow";	for( var a = 0; a < trackingArray.length; a++ ) {		testingString += "\t" + trackingArray[a].row;	}	testingString += "\rcol";	for( var a = 0; a < trackingArray.length; a++ ) {		testingString += "\t" + trackingArray[a].column;	}	testingString += "\rwid";	for( var a = 0; a < trackingArray.length; a++ ) {		testingString += "\t" + Math.floor( artworkToSort[ trackingArray[a].index ].width );	}	testingString += "\rhigh";	for( var a = 0; a < trackingArray.length; a++ ) {		testingString += "\t" + Math.floor( artworkToSort[ trackingArray[a].index ].height );	}	thisTestResult0 = app.activeDocument.textFrames.add();	thisTestResult0.contents = testingString;	thisTestResult0.top = -200;	thisTestResult0.left = 0;		var testingString = "";	for( var a = 0; a < gridSpacingArrayColumns.length; a++ ) {		testingString += "\t" + a;	}	testingString += "\rwid:";	for( var a = 0; a < gridSpacingArrayColumns.length; a++ ) {		testingString += "\t" + Math.floor( gridSpacingArrayColumns[a] );	}	testingString += "\rheigh:";	for( var a = 0; a < gridSpacingArrayRows.length; a++ ) {		testingString += "\t" + Math.floor( gridSpacingArrayRows[a] );	}	thisTestResult = app.activeDocument.textFrames.add();	thisTestResult.contents = testingString;	thisTestResult.top = 0;	thisTestResult.left = 0;	}function sortByWidth(a, b){	//Compare "a" and "b" in some fashion, and return -1, 0, or 1	if( (topHeavy == false) && 		(leftHeavy == true) 	) {		if( a.row != b.row ) {			return 0;		}	}	if( a.width != b.width ) {		return b.width - a.width;	} else {		return b.height - a.height;	}}function sortByHeight(a, b){	//Compare "a" and "b" in some fashion, and return -1, 0, or 1	if( (topHeavy == false) && 		(leftHeavy == true) 	) {		if( a.row != b.row ) {			return 0;		}	}		if( a.height != b.height ) {		return b.height - a.height;	} else {		return b.width - a.width;	}}function sortByArea(a, b){	//Compare "a" and "b" in some fashion, and return -1, 0, or 1	if( a.area != b.area ) {		return b.area - a.area;	} else {		return b.height - a.height;	}}function sortByBounds(a, b){	//Compare "a" and "b" in some fashion, and return -1, 0, or 1	if( a.bounds != b.bounds ) {		return b.bounds - a.bounds;	} else {		return b.height - a.height;	}}function sortByRandom(a, b){	thisDate = new Date();	return (30 - thisDate.getSeconds() );}function importFolderAsLayers(selectedFolder) {		// if a folder was selected continue with action, otherwise quit	var myDocument;	if (selectedFolder) {		myDocument = app.documents.add();				// If there is no crop box, use a nullBox that incorporates the entire page		// Illustrator sets this automatically for File > New menu created documents but not for new documents from scripts		var theNullBox = new Array( 16383, 16383, 16383, 16383 );		myDocument.cropBox = theNullBox;				var firstImageLayer = true;		var newLayer ;		var thisPlacedItem;				// % is %25 in Illustrator, go figure		scalePlacedArtworkViaLayer = false;		scaleFactorXYviaLayer = 100;					if( allowPlacedArtworkScaling ) {						if( selectedFolder.name.indexOf( "%25" ) > -1 ) {				// Could be spurious so let's loop thru and find if a pair				if( selectedFolder.name.indexOf( "%25" ) != selectedFolder.name.lastIndexOf( "%25" ) ) {					scaleFactorXYviaLayer = selectedFolder.name.substring( 	selectedFolder.name.indexOf( "%25" ) + 3, 																						selectedFolder.name.lastIndexOf( "%25" ) 																					);					scalePlacedArtworkViaLayer = true;					//alert( "found scale factor? " + scaleFactorXY );				}			}		}			  		// create document list from files in selected folder		var imageList = selectedFolder.getFiles();		var artworkName = "";			for (var i = 0; i < imageList.length; i++) {			// open each document in file list			if (imageList[i] instanceof File) {				// get the file name				var fName = imageList[i].name.toLowerCase();				// check for supported file formats				if( (fName.indexOf(".eps") == -1) ) {				//if( (fName.indexOf(".eps") == -1) && (fName.indexOf(".gif") == -1) && (fName.indexOf(".jpg") == -1) && (fName.indexOf(".png") == -1) && (fName.indexOf(".bmp") == -1) && (fName.indexOf(".tif") == -1) && (fName.indexOf(".psd") == -1)) {					// skip unsupported formats					continue;				} else {					if( newLayerForEachPlacedItem ) {						if( firstImageLayer ) {							newLayer = myDocument.layers[0];							firstImageLayer = false;						} else {							newLayer = myDocument.layers.add();						}					   // Give the layer the name of the image file					} else {						newLayer = myDocument.activeLayer;					}				   					// % is %25 in Illustrator, go figure					scalePlacedArtworkViaObject = false;					scaleFactorXYviaObject = 100;										if( allowPlacedArtworkScaling ) {							if( fName.indexOf( "%25" ) > -1 ) {							// Could be spurious so let's loop thru and find if a pair							if( fName.indexOf( "%25" ) != fName.lastIndexOf( "%25" ) ) {								scaleFactorXYviaObject = fName.substring( 	fName.indexOf( "%25" ) + 3, 																								fName.lastIndexOf( "%25" ) 																							);								scalePlacedArtworkViaObject = true;								//alert( "found object scale factor? " + scaleFactorXY );							}						}					}				   				    if( scalePlacedArtworkViaObject ) {						artworkName = fName.substring(0, fName.indexOf("%25") );					} else {						artworkName = fName.substring(0, fName.indexOf(".") );					}					if( newLayerForEachPlacedItem ) {						newLayer.name = artworkName;					}				   				   // Place the image on the artboard				   thisPlacedItem = newLayer.placedItems.add()				   thisPlacedItem.file = imageList[i];						   				   // Give that object a name, too				   thisPlacedItem.name = artworkName;				   				   // If the folder should be scaled				   if( scalePlacedArtworkViaLayer ) {					  thisPlacedItem.resize( scaleFactorXYviaLayer,  scaleFactorXYviaLayer );				   }				   				   // If the object should also be scaled, do that after (composite) the layer scaling				   if( scalePlacedArtworkViaObject ) {					  thisPlacedItem.resize( scaleFactorXYviaObject,  scaleFactorXYviaObject );				   }				   				   switch( placement9pointAlignment ) {						default :							break;						case "ul" : 							thisPlacedItem.top = myDocument.height;							thisPlacedItem.left = 0;							break;						case "ml" : 							thisPlacedItem.top = myDocument.height / 2 + thisPlacedItem.height / 2;							thisPlacedItem.left = 0;							break;						case "ll" : 							thisPlacedItem.top = thisPlacedItem.height;							thisPlacedItem.left = 0;							break;						case "ur" : 							thisPlacedItem.top = myDocument.height;							thisPlacedItem.left = myDocument.width - thisPlacedItem.width;							break;						case "mr" : 							thisPlacedItem.top = myDocument.height / 2 + thisPlacedItem.height / 2;							thisPlacedItem.left = myDocument.width - thisPlacedItem.width;							break;						case "lr" : 							thisPlacedItem.top = thisPlacedItem.height;							thisPlacedItem.left = myDocument.width - thisPlacedItem.width;							break;						case "um" : 							thisPlacedItem.top = myDocument.height;							thisPlacedItem.left = myDocument.width / 2 - thisPlacedItem.width / 2;							break;						case "mm" : 							thisPlacedItem.top = myDocument.height / 2 + thisPlacedItem.height / 2;							thisPlacedItem.left = myDocument.width / 2 - thisPlacedItem.width / 2;							break;						case "lm" : 							thisPlacedItem.top = thisPlacedItem.height;							thisPlacedItem.left = myDocument.width / 2 - thisPlacedItem.width / 2;							break;				   }										// WARNING: We loose reference to the artwork at this point				    if( embedPlacedEPSartwork && (fName.indexOf(".eps") > -1)  ) {					   thisPlacedItem.embed();				   }			   				}			}		}				if( newLayerForEachPlacedItem ) {			if( firstImageLayer ) {				// alert("The action has been cancelled.");				// display error message if no supported documents were found in the designated folder				alert("Sorry, but the designated folder does not contain any recognized image formats.\n\nPlease choose another folder.");				myDocument.close();				importFolderAsLayers(getFolder());			}		}			distributeSpacing();			} else {		// alert("The action has been cancelled.");		// display error message if no supported documents were found in the designated folder		alert("Rerun the script and choose a folder with images.");		//importFolderAsLayers(getFolder());	}}// Start the script off//importFolderAsLayers( getFolder() );distributeSpacing();