//==================================================================================// Assign Styles to Layers// Assigns text and graphic styles to objects based on what layer they reside// by (a) matching layer name with style name or (b) script specified style name// If you already have organized your objects into your master template,// this script will quickly "stylize" the generic shapes and raw text into// the standardized "template" look and feel specified.//==================================================================================// (c) Nathaniel Vaughn KELSO// 2008.January.13 - Jan 15th// at Hyattsville, MD// Version 0.2// Requested by Sachin Pradhan// TODO: Graphic Style matching//==================================================================================// To find out what the document layers, character Styles and graphic styles are named// swap out characterStyles with graphicStyles with layers array/parameter names// and comment out the rest of the code below "prompt( alertText, alertText );"/*var styleCount = app.activeDocument.characterStyles.length;alertText = "";for (var ii = 0; ii <= styleCount-1; ii++ ){	alertText += app.activeDocument.characterStyles[ii].name + "/n";}prompt( alertText, alertText );*/////////////////////////////////////////////// Script settings////////////////////////////////////////////// //////////////////////////						      // if BOTH are TRUE, then all objects in the document are processed, else if both False, just the ACTIVE SELECTIONvar examineSelectedOnly = true;					// if true then just the active selection, if false than all objects in document will be evaluatedvar examineHidden = false;						// hidden cannot be selected, so if examineEntireFile = false then this defaults to falsevar examineLocked = false; 						// locked cannot be selected, so if examineEntireFile = false then this defaults to false////////////////////////////////////////////var examineGroupedText = false;var examineGroupedVectors = false;////////////////////////////////////////////// Which method of matching to use?var matchLayerNameWithStyle = true;			// set to true first run, then false if need to customize (layer X = style X)var manualMatching = true;						// layer X = style A// if there is not a specified Style, should it look for// a style with similar attributes?var lookForSameGraphicStyle = true;			// if there is a style that matches the graphic / appearance attributes, use itvar lookForSameCharacterStyle = true;			// if there is a style that matches the character attributes, use it.// and if there is not a match, still look for same style?var allowLookForSameGraphicStyle = true;			// if there is a style that matches the graphic / appearance attributes, use itvar allowLookForSameCharacterStyle = true;			// if there is a style that matches the character attributes, use it.////////////////////////////////////////////var overrideGraphicStyle = true;					// merge or apply the style onto the objectvar overrideCharacterStyle = false;				// if true, remove the (+) marks on the character style indicator////////////////////////////////////////////var restoreGraphicStrokeWeight = true;		// eg 1.5 mm////////////////////////////////////////////var restoreCharacterFontFamiy = false;			// Selectively restore aspects of the font's prior settingvar restoreCharacterFontStyle = false;var restoreCharacterSize = true;var restoreCharacterTracking = true;			// this keyvar restoreCharacterLeading = false;			// this keyvar restoreCharacterFillColor = false;			// TODO: this is not working////////////////////////////////////////////var forceCharacterFontFamiy = false;			// Selectively restore aspects of the font's prior settingvar forceCharacterFontStyle = false;var forceCharacterSize = true;var forceCharacterTracking = false;				// this keyvar forceCharacterLeading = false;				// this keyvar forceCharacterFillColor = false;				// TODO: this is not working////////////////////////////////////////////// How strict on matching Character Styles?var matchCharStyleFontFamily = true; 			// e.g. Timesvar matchCharStyleFontStyle = true;			// e.g. Boldvar matchCharStyleFontSize = true;				// e.g. 12 (points)var matchCharStyleFontFillColor = true;			// eg Black color type versus whitevar matchCharStyleStroke= true;					// eg has a stroke, next 3 take care of what typevar matchCharStyleFontStrokeColor = true;	// eg Black stroked type versus whitevar matchCharStyleFontStrokeWeight = true;	// eg 1.2 ptsvar matchCharStyleFontStrokeDash = false;	// TODO////////////////////////////////////////////// How strict on matching Graphic Styles?var matchGraphicStyleFill = true;					// e.g. has a fill		// e.g. red fill color (regardless of color mode)var matchGraphicStyleStroke = true;			// eg. has a stroke// var matchGraphicStyleFillColor = true;			var matchGraphicStyleStrokeColor = true;		// e.g. black stroke color (regardless of color mode)var matchGraphicStyleStrokeWeight = true;	// e.g. 1.2 pointsvar matchGraphicStyleStrokeDashes = false;	// e.g. 1 pt, 2 pt, 1 pt, 3 pt, 1 pt TODOvar matchGraphicStyleOpacity = true;			// e.g. 100% opacity////////////////////////////////////////////// Store the graphic style attributes in these arraysvar graphicStyleNames = new Array;				// no direct way to determine fill and stroke of graphic styles, so querry them and store herevar graphicStyleIsFilled = new Array;var graphicStyleFills = new Array;var graphicStyleIsStroked = new Array;var graphicStyleStrokeColor = new Array;var graphicStyleStrokeWeight = new Array;var graphicStyleDashes = new Array;var graphicStyleOpacity = new Array;if(documents.length > 0) {	doc = activeDocument;	gatherGraphicStyles();	evaluateObjects( doc );} else {	alert( "Open an Illustrator document first and then run this script." );}function evaluateObjects( doc ) {	var targetDocument = doc;	// mySelection = targetDocument.selection;		if(     matchLayerNameWithStyle || manualMatching 	     || lookForSameGraphicStyle  || lookForSameCharacterStyle	   ) {			var layerCount = targetDocument.layers.length;			// Go thru all that document's layers		for (var ii = layerCount - 1; ii >= 0; ii-- ) {			var styleName = "-99999";						// null doesn't work			var styleNameGraphic = "-99999";			// null doesn't work			var styleNameCharacter = "-99999";			// null doesn't work			var skipThisLayer = false;			targetLayer = targetDocument.layers[ii];			// make sure about the layers, not just the object visibility and locked status			if( examineHidden == false && targetLayer.visible == false ) {				//alert( "found a hidden layer");				continue;			}			if( examineLocked == false && targetLayer.locked == true ) {				//alert( "found a locked layer" );				continue;			}						// automatic route			// where the layer name and graphic or character style name is exactly the same			if( matchLayerNameWithStyle ) {				// Store name of the target layer				thisLayerName = targetLayer.name;				// look for character / graphic styles that match the layer name				styleNameGraphic    = thisLayerName;				styleNameCharacter = thisLayerName;			}			// else manual route			// use the style as specified by "styleName" assignment			if( manualMatching ) {				// Gather text objects and path object and send to evaluation routine				// WARNING: Only works for top level layers (does not work for sub-layers)				switch ( targetLayer.name ) {					case "District/area names" :						styleNameGraphic   = "Area/District";						styleNameCharacter = "Area/District";						break;					case "Title/Scale/key box/N arrow" :						styleNameGraphic   = "Title box | Scale/Key box";						styleNameCharacter = "Title text | Northpoint | Scale bar text | Key text - Titles | Key text - Names | Key text - Number/letters";						break;					case "Country name text" :						styleNameGraphic   = "River fill";						styleNameCharacter = "Country";						break;					case "Chapter divisions boundary" :						styleNameGraphic   = "Chapter boundary";						styleNameCharacter = "Village";						break;					case "National boundaries" :						styleNameGraphic   = "International boundary";						styleNameCharacter = "Village";						break;					case "Chapter highlighter fill" :						styleNameGraphic   = "Locator fill";						styleNameCharacter = "Village";						break;					case "Book fill" :						styleNameGraphic   = "Chapter fill";						styleNameCharacter = "Village";						break;					case "Town stamps" :						styleNameGraphic   = "Black fill";						styleNameCharacter = "Village";						break;					case "village" :						styleNameGraphic   = "River fill";						styleNameCharacter = "Village";						break;					case "Road text" :						styleNameGraphic   = "River fill";						styleNameCharacter = "4pt road";						// alert( "found road text" );						break;					case "Road numbers/names" :						styleNameGraphic   = "River fill";						styleNameCharacter = "4pt road";						break;					case "Natioanl Park text" :						styleNameGraphic   = "River fill";						styleNameCharacter = "National park";						break;					case "Page holdout" :						styleNameGraphic   = "White fill";						styleNameCharacter = "White fill";						break;					case "Coastline" :						styleNameGraphic   = "Coastline/rivers";						styleNameCharacter = "4pt road";						break;					case "Locator numbers" :						styleNameGraphic   = "60% (F) Spot Circles";						styleNameCharacter = "Locator numbers white";						break;					case "Title text" :						styleNameGraphic   = "Title box";						styleNameCharacter = "Title text";						break;					case "Scale" :						styleNameGraphic   = "Scale/Key box";						styleNameCharacter = "Scale bar text";						break;					case "Key box" :						styleNameGraphic   = "Scale/Key box";						styleNameCharacter = "Key text - Names";						break;					case "Frame information" :						styleNameGraphic   = "abc";						styleNameCharacter = "Genoa (arrow off)";						break;					case "Park fill" :						styleNameGraphic   = "Park/forest fill";						styleNameCharacter = "4pt road";						break;					case "River/Lake /Bays & Straits text" :						styleNameGraphic   = "Water";						styleNameCharacter = "Rivers/Lakes/Bays & Straits";						break;					case "Railway case (above road)" :						styleNameGraphic   = "Rail case";						styleNameCharacter = "Village";						break;					case "Railway pecks (above road)" :						styleNameGraphic   = "Rail peck";						styleNameCharacter = "Village";						break;					case "top building" :						styleNameGraphic   = "Buildings";						styleNameCharacter = "Village";						break;					case "Buildings" :						styleNameGraphic   = "Buildings";						styleNameCharacter = "Village";						break;					case "Background fill" :						styleNameGraphic   = "Background fill";						styleNameCharacter = "Village";						break;					case "0.7 road case" :						styleNameGraphic   = "0.7 road case";						styleNameCharacter = "Village";						break;					case "Restaurant location numbers" :						styleNameGraphic    = "4.5pt Letters/Numbers";						styleNameCharacter = "4.5pt Letters/Numbers";						break;					case "Rail peak" :						styleNameGraphic    = "Rail top";						styleNameCharacter = "4.5pt Letters/Numbers";						break;					case "City text" :						styleNameGraphic    = "4.5pt Letters/Numbers";						styleNameCharacter = "City";						break;					case "Road text" :						styleNameGraphic    = "4.5pt Letters/Numbers";						styleNameCharacter = "4pt road";						break;					case "Places of interest text" :						styleNameGraphic    = "4.5pt Letters/Numbers";						styleNameCharacter = "Place of interest";						break;					case "Hotels/restaurants text" :						// styleNameGraphic    = "4.5pt Letters/Numbers";						styleNameCharacter = "Hotel/Restaurant";						break;					case "Area text" :						styleNameGraphic    = "4.5pt Letters/Numbers";						styleNameCharacter = "Area";						break;					case "Title/Scale/key box/N arrow" :						styleNameGraphic    = "Scale bar text";						styleNameCharacter = "Scale bar text";						break;				}			}					// if we want to skip a certain layer name			switch ( targetLayer.name ) {				case "old_____________________" :					skipThisLayer = true;					break;			}					// gather that layers page items together			if( skipThisLayer ) {				continue;			} else {				layerPageItems = targetLayer.pageItems;				layerPageItemsLength = layerPageItems.length;				theTextItems = new Array();				thePathItems = new Array();				for( k=0; k<layerPageItemsLength; k++ ) {					thisLayerPageItem = layerPageItems[k];					// If a group of one, we'll give you a bonus treat of evaluating the content					if( thisLayerPageItem.typename == "GroupItem" ){						//alert( "found a group" );						evaluateGroup( thisLayerPageItem, theTextItems, thePathItems );						continue;					}					evaluateObject( thisLayerPageItem, theTextItems, thePathItems );				}				// Now send all objects on that layer to be styled				// But only if there is a target style to associate with those objects				if( styleNameGraphic ||  styleNameCharacter ) {					applyGraphicStyles(    thePathItems, styleNameGraphic   );					applyCharacterStyles( theTextItems, styleNameCharacter );				}			}		}	}}function evaluateGroup( thisLayerPageItem, theTextItems, thePathItems ) {	//if( thisLayerPageItem.typename == "GroupItem" ){		//alert( "found a grouped group" );		//evaluateGroup( thisLayerPageItem, theTextItems, thePathItems );	//} else {		theGroupLength = thisLayerPageItem.pageItems.length;		for( h=theGroupLength-1; h>=0; h-- )		{			thisGroupItem = thisLayerPageItem.pageItems[h];			if( examineGroupedText ) {				theTextItems.push(thisGroupItem);			}			if( examineGroupedVectors ) {				thePathItems.push(thisGroupItem);			}												}	//}}function evaluateObject( thisLayerPageItem, theTextItems, thePathItems ) {	if( examineHidden && examineLocked ) { 		if( examineSelectedOnly &&  thisLayerPageItem.selected == true  ) {			if(thisLayerPageItem.typename == "TextFrame"){				theTextItems.push(thisLayerPageItem);			}			 if(thisLayerPageItem.typename == "PathItem"){				thePathItems.push(thisLayerPageItem);			}		} else if( examineSelectedOnly == false ) {			if(thisLayerPageItem.typename == "TextFrame"){				theTextItems.push(thisLayerPageItem);			}			 if(thisLayerPageItem.typename == "PathItem"){				thePathItems.push(thisLayerPageItem);			}		}	} else if( examineHidden == false && examineLocked == false ) {		if( examineSelectedOnly &&  thisLayerPageItem.selected == true  ) {			if(thisLayerPageItem.typename == "TextFrame" && thisLayerPageItem.hidden == false && thisLayerPageItem.locked == false ){				theTextItems.push(thisLayerPageItem);			} else if(thisLayerPageItem.typename == "PathItem" && thisLayerPageItem.hidden == false && thisLayerPageItem.locked == false ){				thePathItems.push(thisLayerPageItem);			}		} else if( examineSelectedOnly == false ) {			if(thisLayerPageItem.typename == "TextFrame" && thisLayerPageItem.hidden == false && thisLayerPageItem.locked == false ){				theTextItems.push(thisLayerPageItem);			} else if(layerPageItems.typename == "PathItem" && thisLayerPageItem.hidden == false && thisLayerPageItem.locked == false ){				thePathItems.push(thisLayerPageItem);			}		}	} else if( examineHidden == false && examineLocked == true ) {		if( examineSelectedOnly &&  thisLayerPageItem.selected == true  ) {			if(thisLayerPageItem.typename == "TextFrame" && thisLayerPageItem.hidden == false ){				theTextItems.push(thisLayerPageItem);			} else if(thisLayerPageItem.typename == "PathItem" && thisLayerPageItem.hidden == false ){				thePathItems.push(thisLayerPageItem);			}		} else if( examineSelectedOnly == false ) {			if(thisLayerPageItem.typename == "TextFrame" && thisLayerPageItem.hidden == false ){				theTextItems.push(thisLayerPageItem);			} else if(thisLayerPageItem.typename == "PathItem" && thisLayerPageItem.hidden == false ){				thePathItems.push(thisLayerPageItem);			}		}	} else if( examineHidden == true && examineLocked == false ) {		if( examineSelectedOnly &&  thisLayerPageItem.selected == true  ) {			if(thisLayerPageItem.typename == "TextFrame" && thisLayerPageItem.locked == false ){				theTextItems.push(thisLayerPageItem);			} else if(thisLayerPageItem.typename == "PathItem" && thisLayerPageItem.locked == false ){				thePathItems.push(thisLayerPageItem);			}		} else if( examineSelectedOnly == false ) {			if(thisLayerPageItem.typename == "TextFrame" && thisLayerPageItem.locked == false ){				theTextItems.push(thisLayerPageItem);			} else if(thisLayerPageItem.typename == "PathItem" && thisLayerPageItem.locked == false ){				thePathItems.push(thisLayerPageItem);			}		}	}}function applyCharacterStyles( theItems, styleName){	var tempLookForSameStyle = new Boolean;	tempLookForSameStyle = false;		if( styleName == null || lookForSameCharacterStyle) {		tempLookForSameStyle = true;	} else if( styleName == "-99999" ) {		tempLookForSameStyle = true;	} else {		tempLookForSameStyle = false;	}	numberStyles = activeDocument.characterStyles.length;								// Make sure there is a style by that name	// Even though the user said to use it, maybe it does not exist	// If it does not exist, than see if there is a matching character style	var styleExists = false;	for( a=0; a < numberStyles; a++ ) {		if( doc.characterStyles[a].name != styleName ) {			continue;		}		styleExists = true;		break;	}	if ( styleExists && lookForSameCharacterStyle ) { 		tempLookForSameStyle = true;	} else {		tempLookForSameStyle = false;	}	var endIndex = theItems.length;	// make sure there are items to process!	if( endIndex > 0 ) {		for ( i = 0; i < endIndex; i++ ) {			thisItem = theItems[i];			styleExists = false;			// TODO: This test is redundant	since we already gathered and sorted the elements?			if ( theItems[i].typename == "TextFrame" ) {				// even if there is already a character style specified, look to see if there is an existing style like used on the object and match to that instead				if( tempLookForSameStyle) {					for( var ii = 0; ii < numberStyles; ii++ ) {						fontFamilyMatches = false;						fontStyleMatches   = false;						fontSizeMatches    = false;						fontFillMatches      = false;						fontStrokeMatches = false;						fontStrokeColorMatches = false						fontStrokeWeightMatches = false;						fontStrokeDashMatches = false;			// TODO												// if there is a similar character style (only compare font face and style and size) 						// then use that instead of the user provided style via styleName						if( matchCharStyleFontFamily ) {							try{ 								if( thisItem.textRange.textFont.family != doc.characterStyles[ii].characterAttributes.textFont.family ) {									continue;														// eg skip to next for loop without exicuting the next if statements, etc								} else {									fontFamilyMatches = true;								// we found something good								}							} catch(e) { fontFamilyMatches = false; }						} else if( matchCharStyleFontFamily  == false ) {							fontFamilyMatches = true;									// we didn't care in the 1st place						}						if( matchCharStyleFontStyle ) {							try{ 								if( thisItem.textRange.textFont.style != doc.characterStyles[ii].characterAttributes.textFont.style ) {									continue;													// eg skip to next for loop without exicuting the next if statements, etc								} else {									fontStyleMatches = true;									// we found something good								}							} catch(e) { fontStyleMatches = false; }						} else if( matchCharStyleFontFamily  == false ) {							fontStyleMatches = true;										// we didn't care in the 1st place						}						if( matchCharStyleFontSize ) {							try{ 								if( thisItem.textRange.size != doc.characterStyles[ii].characterAttributes.size  ) {									continue;													// eg skip to next for loop without exicuting the next if statements, etc								} else {									fontSizeMatches = true;									// we found something good								}							} catch(e)  { fontSizeMatches = false; }						} else if( matchCharStyleFontFamily  == false ) {							fontSizeMatches = true;										// we didn't care in the 1st place						}													if( matchCharStyleFontFillColor && thisItem.filled ) {							// alert( "got to fill test" );							//if( thisItem.filled != graphicStyleIsFilled[ii] ) {								//continue;							//} else {								//alert( "we might have a FILL match, let's look..." );								if( tempMatchGraphicStyleFill ) {			// was ref to tempMatchGraphicStyleFillColor but that seemed redundant since only color for Fill									if( thisItem.textRange.fillColor.typename == "NoColor" && graphicStyleFills[ii].typename == "NoColor" ) {										// Nothing further to test, there is a match										fontFillMatches = true;	// we found something good									}																		if( thisItem.textRange.fillColor.typename == "CMYKColor" && graphicStyleFills[ii].typename == "CMYKColor" ) {										if( thisItem.textRange.fillColor.black != graphicStyleFills[ii].black 												 ||  thisItem.textRange.fillColor.cyan != graphicStyleFills[ii].cyan 												 ||  thisItem.textRange.fillColor.magenta != graphicStyleFills[ii].magenta 												 ||  thisItem.textRange.fillColor.yellow != graphicStyleFills[ii].yellow  										  ) {												continue;	// eg skip to next for loop without exicuting the next if statements, etc										} else {											fontFillMatches = true;	// we found something good										}										//alert( "matched cmyk fills: " + graphicStyleNames[ii] );									}									if( thisItem.textRange.fillColor.typename == "RGBColor" && graphicStyleFills[ii].typename == "RGBColor" ) {										if( thisItem.textRange.fillColor.blue != graphicStyleFills[ii].blue 												 ||  thisItem.textRange.fillColor.green != graphicStyleFills[ii].green 												 ||  thisItem.textRange.fillColor.red != graphicStyleFills[ii].red  										   ) {												continue;	// eg skip to next for loop without exicuting the next if statements, etc										} else {											fontFillMatches = true;	// we found something good										}										//alert( "matched rbg fills: " + graphicStyleNames[ii] );									}									if( thisItem.textRange.fillColor.typename == "GrayColor" && graphicStyleFills[ii].typename == "GrayColor" ) {										if( thisItem.textRange.fillColor.gray != graphicStyleFills[ii].gray ) {											continue;	// eg skip to next for loop without exicuting the next if statements, etc										} else {											fontFillMatches = true;	// we found something good										}										//alert( "matched grayscale fills: " + graphicStyleNames[ii] );									}									/*									if( thisItem.fillColor.typename == "GradientColor" && graphicStyleFills[ii].typename == "GradientColor" ) {										if( thisItem.fillColor.gradient.gradientStops.length == graphicStyleFills[ii].gradient.gradientStops.length ) {											// make sure all the stops are the same											for( x=0; x<thisItem.fillColor.gradient.gradientStops.length; x++ ) {												if( thisItem.textRange.fillColor.gradient.gradientStops[x].color.typename == "CMYKColor" && graphicStyleFills[ii].gradient.gradientStops[x].color.typename == "CMYKColor" ) {													if( thisItem.textRange.fillColor.gradient.gradientStops[x].color.black                 != graphicStyleFills[ii].gradient.gradientStops[x].color.black 															 ||  thisItem.textRange.fillColor.gradient.gradientStops[x].color.cyan       != graphicStyleFills[ii].gradient.gradientStops[x].color.cyan 															 ||  thisItem.textRange.fillColor.gradient.gradientStops[x].color.magenta != graphicStyleFills[ii].gradient.gradientStops[x].color.magenta 															 ||  thisItem.textRange.fillColor.gradient.gradientStops[x].color.yellow      != graphicStyleFills[ii].gradient.gradientStops[x].color.yellow  													  ) {															break;	// eg skip to next for loop without exicuting the next if statements, etc													} else {														fontFillMatches = true;	// we found something good														break;													}													//alert( "matched GRADIENT cmyk fills: " + graphicStyleNames[ii] );												}												if( thisItem.textRange.fillColor.gradient.gradientStops[x].color.typename == "RGBColor" && graphicStyleFills[ii].gradient.gradientStops[x].color.typename == "RGBColor" ) {													if( thisItem.textRange.fillColor.gradient.gradientStops[x].color.blue             != graphicStyleFills[ii].gradient.gradientStops[x].color.blue 															 ||    thisItem.textRange.fillColor.gradient.gradientStops[x].color.green != graphicStyleFills[ii].gradient.gradientStops[x].color.green 															 ||   thisItem.textRange.fillColor.gradient.gradientStops[x].color.red     != graphicStyleFills[ii].gradient.gradientStops[x].color.red  													   ) {															break;	// eg skip to next for loop without exicuting the next if statements, etc													} else {														fontFillMatches = true;	// we found something good														break;													}													//alert( "matched GRADIENT rbg fills: " + graphicStyleNames[ii] );												}												if( thisItem.textRange.fillColor.gradient.gradientStops[x].color.typename == "GrayColor" && graphicStyleFills[ii].gradient.gradientStops[x].color.typename == "GrayColor" ) {													if( thisItem.textRange.fillColor.gradient.gradientStops[x].color.gray != graphicStyleFills[ii].gradient.gradientStops[x].color.gray ) {														break;	// eg skip to next for loop without exicuting the next if statements, etc													} else {														fontFillMatches = true;	// we found something good														break;													}													//alert( "matched GRADIENT grayscale fills: " + graphicStyleNames[ii] );												}												if( thisItem.textRange.fillColor.gradient.gradientStops[x].color.typename == "LabColor" && graphicStyleFills[ii].gradient.gradientStops[x].color.typename == "LabColor" ) {													if( thisItem.textRange.fillColor.gradient.gradientStops[x].color.a          != graphicStyleFills[ii].gradient.gradientStops[x].color.a 															 ||    thisItem.textRange.fillColor.gradient.gradientStops[x].color.b != graphicStyleFills[ii].gradient.gradientStops[x].color.b 															 ||    thisItem.textRange.fillColor.gradient.gradientStops[x].color.l  != graphicStyleFills[ii].gradient.gradientStops[x].color.l  													   ) {															break;	// eg skip to next for loop without exicuting the next if statements, etc													} else {														fontFillMatches = true;	// we found something good														break;													}													//alert( "matched GRADIENT LabColor fills: " + graphicStyleNames[ii]);												}												if( thisItem.textRange.fillColor.gradient.gradientStops[x].color.typename == "SpotColor" && graphicStyleFills[ii].gradient.gradientStops[x].color.typename == "SpotColor" ) {													if( thisItem.textRange.fillColor.gradient.gradientStops[x].color.spot         != graphicStyleFills[ii].gradient.gradientStops[x].color.spot															 ||    thisItem.textRange.fillColor.gradient.gradientStops[x].color.tint != graphicStyleFills[ii].gradient.gradientStops[x].color.tint  													   ) {															break;	// eg skip to next for loop without exicuting the next if statements, etc													} else {														fontFillMatches = true;	// we found something good														break;													}													//alert( "matched GRADIENT SpotColor fills: " + graphicStyleNames[ii] );												// needed a catch all continue if something else here												}											} 											// alert( "matched GradientColor fills: " + graphicStyleNames[ii] );										} else {											continue;	// eg skip to next for loop without exicuting the next if statements, etc										}									} */									if( thisItem.textRange.fillColor.typename == "LabColor" && graphicStyleFills[ii].typename == "LabColor" ) {										if( thisItem.textRange.fillColor.a 			!= graphicStyleFills[ii].a 												 ||  thisItem.textRange.fillColor.b != graphicStyleFills[ii].b 												 ||  thisItem.textRange.fillColor.l  != graphicStyleFills[ii].l  										   ) {												continue;	// eg skip to next for loop without exicuting the next if statements, etc										} else {											fontFillMatches = true;	// we found something good										}										//alert( "matched LabColor fills: " + graphicStyleNames[ii]);									}									if( thisItem.textRange.fillColor.typename == "PatternColor" && graphicStyleFills[ii].typename == "PatternColor" ) {										if( thisItem.textRange.fillColor.pattern !=graphicStyleFills[ii].pattern  ) {											continue;	// eg skip to next for loop without exicuting the next if statements, etc										} else {											fontFillMatches = true;	// we found something good										}										//alert( "matched LabColor fills: " + graphicStyleNames[ii] );									}									if( thisItem.textRange.fillColor.typename == "SpotColor" && graphicStyleFills[ii].typename == "SpotColor" ) {										if( thisItem.textRange.fillColor.spot 		   != graphicStyleFills[ii].spot												 ||  thisItem.textRange.fillColor.tint != graphicStyleFills[ii].tint  ) {											continue;	// eg skip to next for loop without exicuting the next if statements, etc										} else {											fontFillMatches = true;	// we found something good										}										//alert( "matched SpotColor fills: " + graphicStyleNames[ii] );									}									//alert( "matched fills: " + graphicStyleNames[ii] );								}							//}							//foundMatch = false;		// this is now explicate in each test						} else if( matchCharStyleFontFillColor && (thisItem.filled == false && graphicStyleIsFilled[ii] == false)  ) {							fontFillMatches = true;							} else if( matchCharStyleFontFillColor == false ) {							fontFillMatches = true;						// we don't care if we found something good						}												if( matchCharStyleStroke && thisItem.stroked ) {							// alert( "got to STROKE test" );							//if( thisItem.stroked != graphicStyleIsStroked[ii] ) {								//continue;							//} else {								//alert( "might have a STROKE match, let's look..." );								if( matchCharStyleFontStrokeColor ) {									if( thisItem.textRange.fillColor.typename == "NoColor" && graphicStyleFills[ii].typename == "NoColor" ) {										// Nothing further to test, there is a match										fontStrokeColorMatches = true;	// we found something good									}																	if( thisItem.textRange.strokeColor.typename == "CMYKColor" && graphicStyleStrokeColor[ii].typename == "CMYKColor" ) {										if( 		 thisItem.textRange.strokeColor.black 		!= graphicStyleStrokeColor[ii].black 												 ||  thisItem.textRange.strokeColor.cyan 		!= graphicStyleStrokeColor[ii].cyan 												 ||  thisItem.textRange.strokeColor.magenta != graphicStyleStrokeColor[ii].magenta 												 ||  thisItem.textRange.strokeColor.yellow 	!= graphicStyleStrokeColor[ii].yellow  											   ) {												continue;																	// eg skip to next for loop without exicuting the next if statements, etc										} else {											fontStrokeColorMatches = true;							// we found something good										}										//alert( "matched cmyk strokes: " + graphicStyleNames[ii] );									}									if( thisItem.textRange.strokeColor.typename == "RGBColor" && graphicStyleStrokeColor[ii].typename == "RGBColor" ) {										if( 		  thisItem.textRange.strokeColor.blue  != graphicStyleStrokeColor[ii].blue 												 ||  thisItem.textRange.strokeColor.green != graphicStyleStrokeColor[ii].green 												 ||  thisItem.textRange.strokeColor.red    != graphicStyleStrokeColor[ii].red  											   ) {												continue;																		// eg skip to next for loop without exicuting the next if statements, etc										} else {											fontStrokeColorMatches = true;							// we found something good										}										//alert( "matched rbg strokes: " + graphicStyleNames[ii] );									}									if( thisItem.textRange.strokeColor.typename == "GrayColor" && graphicStyleStrokeColor[ii].typename == "GrayColor" ) {										if( thisItem.textRange.strokeColor.gray != graphicStyleStrokeColor[ii].gray ) {											continue;																		// eg skip to next for loop without exicuting the next if statements, etc										} else {											fontStrokeColorMatches = true;							// we found something good										}										//alert( "matched grayscale strokes: " + graphicStyleNames[ii] );									}									// UP to CS3 does not support Gradients on Strokes (while Flash does)									/*if( thisItem.strokeColor.typename == "GradientColor" && graphicStyleStrokeColor[ii].typename == "GradientColor" ) {										if( thisItem.strokeColor.gradient != graphicStyleStrokeColor[ii].gradient ) {											continue;											}										alert( "matched GradientColor strokes: " + graphicStyleNames[ii] );									}*/									if( thisItem.textRange.strokeColor.typename == "LabColor" && graphicStyleStrokeColor[ii].typename == "LabColor" ) {										if( thisItem.textRange.strokeColor.a != graphicStyleStrokeColor[ii].a 												 || thisItem.textRange.strokeColor.b != graphicStyleStrokeColor[ii].b 												 || thisItem.textRange.strokeColor.l != graphicStyleStrokeColor[ii].l  										   ) {												continue;	// eg skip to next for loop without exicuting the next if statements, etc										} else {											fontStrokeColorMatches = true;	// we found something good										}										//alert( "matched LabColor strokes: " + graphicStyleNames[ii]);									}									// UP to CS3 does not support Patterns on Strokes									/*if( thisItem.strokeColor.typename == "PatternColor" && graphicStyleStrokeColor[ii].typename == "PatternColor" ) {										if( thisItem.strokeColor.pattern != graphicStyleStrokeColor[ii].pattern  ) {											continue;										}										alert( "matched LabColor strokes: " + graphicStyleNames[ii] );									}*/									if( thisItem.textRange.strokeColor.typename == "SpotColor" && graphicStyleStrokeColor[ii].typename == "SpotColor" ) {										if( thisItem.textRange.strokeColor.spot != graphicStyleStrokeColor[ii].spot												 ||  thisItem.textRange.strokeColor.tint != graphicStyleStrokeColor[ii].tint  										   ) {												continue;															// eg skip to next for loop without exicuting the next if statements, etc										} else {											fontStrokeColorMatches = true;				// we found something good										}										//alert( "matched SpotColor strokes: " + graphicStyleNames[ii] );									}									//alert( "matched strokes: " + graphicStyleNames[ii] );								} else if( matchCharStyleFontStrokeColor == false ) {									fontStrokeColorMatches = true;						// we don't care if we found something good								}															if( matchCharStyleFontStrokeWeight ) {									if( thisItem.textRange.strokeWidth != graphicStyleStrokeWeight[ii] ) {										continue;																// eg skip to next for loop without exicuting the next if statements, etc									} else {										fontStrokeWeightMatches = true;				// we found something good									}								} else if( matchCharStyleFontStrokeWeight == false ) {									fontStrokeWeightMatches = true;					// we don't care if we found something good								}								if( matchCharStyleFontStrokeDash ) {									// TODO: null condition detection									if( thisItem.textRange.strokeDashes != graphicStyleDashes[ii] ) {										continue;																// eg skip to next for loop without exicuting the next if statements, etc									} else {										matchCharStyleFontStrokeDash = true;				// we found something good									}									//alert( "matched stroke dash style: " + graphicStyleNames[ii] );								} else if( matchCharStyleFontStrokeDash == false ) {									fontStrokeDashMatches = true;					// we don't care if we found something good								}							//}							if(      fontStrokeColorMatches 								&& fontStrokeWeightMatches 								&& fontStrokeDashMatches								) {										fontStrokeMatches = true;						// we found something good 							}						} else if( matchCharStyleStroke && (thisItem.stroked == false && graphicStyleIsStroked[ii] == false)  ) {							fontStrokeMatches = true;							} else if( matchCharStyleStroke == false ) {							fontStrokeMatches = true;						// we don't care if we found something good						}								// If we've gotten this far, we've found the style						if( fontFamilyMatches && fontStyleMatches && fontSizeMatches && fontFillMatches && fontStrokeMatches ) {							styleName = doc.characterStyles[ii].name;							// and don't need to go any farther							break;						}					}				}				// Make sure there is a style by that name				for( j=0; j < numberStyles; j++ ) {					if( doc.characterStyles[j].name == styleName ) {						styleExists = true;						//break;					}				}				// WARNING! Just finds the 1st instance of the name, does not check for duplicate style names! 				if ( styleExists ) {						//alert( styleName );										// but store the old attributes					oldCharFontFamily = thisItem.textRange.textFont.family;					oldCharFontStyle =  thisItem.textRange.textFont.style;					oldCharSize = thisItem.textRange.size;					oldCharTracking = thisItem.textRange.tracking;					oldCharLeading = thisItem.textRange.leading;					// oldCharFillColor = thisItem.textRange.fillColor;					// oldCharStrokeColor = thisItem.textRange.strokeColor;											if( overrideCharacterStyle ) {						// force the type to be EXACTLY the character style attributes						doc.characterStyles[styleName].applyTo( thisItem.textRange, true );												if( restoreCharacterFontFamiy ) {							thisItem.textRange.textFont.family = oldCharFontFamily;						}						if( restoreCharacterFontStyle) {							thisItem.textRange.textFont.style = oldCharFontStyle;						}						if( restoreCharacterSize) {							thisItem.textRange.size = oldCharSize;						}						if( restoreCharacterTracking ) {							thisItem.textRange.tracking = oldCharTracking;						}						if( restoreCharacterLeading ) {							thisItem.textRange.leading = oldCharLeading;						}						/*if( restoreCharacterFillColor ) {							thisItem.textRange.fillColor = oldCharFillColor;						}*/					} else {						// don't clear overrides (kerning, leading, size)						doc.characterStyles[styleName].applyTo( thisItem.textRange, false );												if( forceCharacterFontFamiy ) {							thisItem.textRange.textFont.family = oldCharFontFamily;						}						if( forceCharacterFontStyle) {							thisItem.textRange.textFont.style = oldCharFontStyle;						}						if( forceCharacterSize) {							thisItem.textRange.size = oldCharSize;						}						if( forceCharacterTracking ) {							thisItem.textRange.tracking = oldCharTracking;						}						if( forceCharacterLeading ) {							thisItem.textRange.leading = oldCharLeading;						}						/*if( restoreCharacterFillColor ) {							thisItem.textRange.fillColor = oldCharFillColor;						}*/					}				}			}		}	}}function applyGraphicStyles( theItems, styleName){	var tempLookForSameStyle = new Boolean;	tempLookForSameStyle = false;		if( styleName == null || lookForSameGraphicStyle) {		//if( styleName == null ) {		tempLookForSameStyle = true;	} else if( styleName == "-99999" ) {		tempLookForSameStyle = true;	} else {		tempLookForSameStyle = false;	}	numberStyles = graphicStyleNames.length;	// Make sure there is a style by that name	// Even though the user said to use it, maybe it does not exist	// If it does not exist, than see if there is a matching character style	var styleExists = false;	for( a=0; a < numberStyles; a++ ) {		if( doc.graphicStyles[a].name != styleName ) {			continue;		}		styleExists = true;		break;	}	//* turn this back on when the character sorting gets figured out	if ( styleExists ) { 		if( allowLookForSameGraphicStyle ) {			tempLookForSameStyle = true;		} else {			tempLookForSameStyle = false;		}	} else {		if( allowLookForSameGraphicStyle ) {			tempLookForSameStyle = true;		} else {			tempLookForSameStyle = false;		}	}	//*/	var endIndex = theItems.length;	// make sure there are items to process!	if( endIndex > 0 ) {		for ( i = 0; i < endIndex; i++ ) {			thisItem = theItems[i];						styleExists = false;			tempMatchedStyle = false;			// TODO: This test is redundant	since we already gathered and sorted the elements?			if ( theItems[i].typename == "PathItem" ) {				// even if there is already a character style specified, look to see if there is an existing style like used on the object and match to that instead				if( tempLookForSameStyle) {					// look for similar graphic styles										for( var ii = 0; ii < numberStyles; ii++ ) {					// for (var ii = numberStyles-1; ii >= 0; ii-- ) {						foundMatch = false;						tempMatchGraphicStyleFill = false;					// e.g. has a fill ,,  e.g. red fill color (regardless of color mode)						tempMatchGraphicStyleStroke = false;			 	// eg. has a stroke	//					tempMatchGraphicStyleFillColor = false;										tempMatchGraphicStyleStrokeColor = false;		// e.g. black stroke color (regardless of color mode)						tempMatchGraphicStyleStrokeWeight = false;		// e.g. 1.2 points						tempMatchGraphicStyleStrokeDashes = false;	// wide then wide (2, 0.5, 2)						tempMatchGraphicStyleOpacity = false;				// e.g. 100% opacity						if( matchGraphicStyleFill && thisItem.filled ) {							// alert( "got to fill test" );							if( thisItem.filled != graphicStyleIsFilled[ii] ) {								continue;							} else {								//alert( "we might have a FILL match, let's look..." );								if( tempMatchGraphicStyleFill ) {			// was ref to tempMatchGraphicStyleFillColor but that seemed redundant since only color for Fill									if( thisItem.fillColor.typename == "NoColor" && graphicStyleFills[ii].typename == "NoColor" ) {										// Nothing further to test, there is a match										tempMatchGraphicStyleFill = true;	// we found something good									}																		if( thisItem.fillColor.typename == "CMYKColor" && graphicStyleFills[ii].typename == "CMYKColor" ) {										if( thisItem.fillColor.black != graphicStyleFills[ii].black 												 ||  thisItem.fillColor.cyan != graphicStyleFills[ii].cyan 												 ||  thisItem.fillColor.magenta != graphicStyleFills[ii].magenta 												 ||  thisItem.fillColor.yellow != graphicStyleFills[ii].yellow  										  ) {												continue;	// eg skip to next for loop without exicuting the next if statements, etc										} else {											tempMatchGraphicStyleFill = true;	// we found something good										}										//alert( "matched cmyk fills: " + graphicStyleNames[ii] );									}									if( thisItem.fillColor.typename == "RGBColor" && graphicStyleFills[ii].typename == "RGBColor" ) {										if( thisItem.fillColor.blue != graphicStyleFills[ii].blue 												 ||  thisItem.fillColor.green != graphicStyleFills[ii].green 												 ||  thisItem.fillColor.red != graphicStyleFills[ii].red  										   ) {												continue;	// eg skip to next for loop without exicuting the next if statements, etc										} else {											tempMatchGraphicStyleFill = true;	// we found something good										}										//alert( "matched rbg fills: " + graphicStyleNames[ii] );									}									if( thisItem.fillColor.typename == "GrayColor" && graphicStyleFills[ii].typename == "GrayColor" ) {										if( thisItem.fillColor.gray != graphicStyleFills[ii].gray ) {											continue;	// eg skip to next for loop without exicuting the next if statements, etc										} else {											tempMatchGraphicStyleFill = true;	// we found something good										}										//alert( "matched grayscale fills: " + graphicStyleNames[ii] );									}									if( thisItem.fillColor.typename == "GradientColor" && graphicStyleFills[ii].typename == "GradientColor" ) {										if( thisItem.fillColor.gradient.gradientStops.length == graphicStyleFills[ii].gradient.gradientStops.length ) {											// make sure all the stops are the same											for( x=0; x<thisItem.fillColor.gradient.gradientStops.length; x++ ) {												if( thisItem.fillColor.gradient.gradientStops[x].color.typename == "CMYKColor" && graphicStyleFills[ii].gradient.gradientStops[x].color.typename == "CMYKColor" ) {													if( thisItem.fillColor.gradient.gradientStops[x].color.black                 != graphicStyleFills[ii].gradient.gradientStops[x].color.black 															 ||  thisItem.fillColor.gradient.gradientStops[x].color.cyan       != graphicStyleFills[ii].gradient.gradientStops[x].color.cyan 															 ||  thisItem.fillColor.gradient.gradientStops[x].color.magenta != graphicStyleFills[ii].gradient.gradientStops[x].color.magenta 															 ||  thisItem.fillColor.gradient.gradientStops[x].color.yellow      != graphicStyleFills[ii].gradient.gradientStops[x].color.yellow  													  ) {															break;	// eg skip to next for loop without exicuting the next if statements, etc													} else {														tempMatchGraphicStyleFill = true;	// we found something good														break;													}													//alert( "matched GRADIENT cmyk fills: " + graphicStyleNames[ii] );												}												if( thisItem.fillColor.gradient.gradientStops[x].color.typename == "RGBColor" && graphicStyleFills[ii].gradient.gradientStops[x].color.typename == "RGBColor" ) {													if( thisItem.fillColor.gradient.gradientStops[x].color.blue             != graphicStyleFills[ii].gradient.gradientStops[x].color.blue 															 ||    thisItem.fillColor.gradient.gradientStops[x].color.green != graphicStyleFills[ii].gradient.gradientStops[x].color.green 															 ||   thisItem.fillColor.gradient.gradientStops[x].color.red     != graphicStyleFills[ii].gradient.gradientStops[x].color.red  													   ) {															break;	// eg skip to next for loop without exicuting the next if statements, etc													} else {														tempMatchGraphicStyleFill = true;	// we found something good														break;													}													//alert( "matched GRADIENT rbg fills: " + graphicStyleNames[ii] );												}												if( thisItem.fillColor.gradient.gradientStops[x].color.typename == "GrayColor" && graphicStyleFills[ii].gradient.gradientStops[x].color.typename == "GrayColor" ) {													if( thisItem.fillColor.gradient.gradientStops[x].color.gray != graphicStyleFills[ii].gradient.gradientStops[x].color.gray ) {														break;	// eg skip to next for loop without exicuting the next if statements, etc													} else {														tempMatchGraphicStyleFill = true;	// we found something good														break;													}													//alert( "matched GRADIENT grayscale fills: " + graphicStyleNames[ii] );												}												if( thisItem.fillColor.gradient.gradientStops[x].color.typename == "LabColor" && graphicStyleFills[ii].gradient.gradientStops[x].color.typename == "LabColor" ) {													if( thisItem.fillColor.gradient.gradientStops[x].color.a          != graphicStyleFills[ii].gradient.gradientStops[x].color.a 															 ||    thisItem.fillColor.gradient.gradientStops[x].color.b != graphicStyleFills[ii].gradient.gradientStops[x].color.b 															 ||    thisItem.fillColor.gradient.gradientStops[x].color.l  != graphicStyleFills[ii].gradient.gradientStops[x].color.l  													   ) {															break;	// eg skip to next for loop without exicuting the next if statements, etc													} else {														tempMatchGraphicStyleFill = true;	// we found something good														break;													}													//alert( "matched GRADIENT LabColor fills: " + graphicStyleNames[ii]);												}												if( thisItem.fillColor.gradient.gradientStops[x].color.typename == "SpotColor" && graphicStyleFills[ii].gradient.gradientStops[x].color.typename == "SpotColor" ) {													if( thisItem.fillColor.gradient.gradientStops[x].color.spot         != graphicStyleFills[ii].gradient.gradientStops[x].color.spot															 ||    thisItem.fillColor.gradient.gradientStops[x].color.tint != graphicStyleFills[ii].gradient.gradientStops[x].color.tint  													   ) {															break;	// eg skip to next for loop without exicuting the next if statements, etc													} else {														tempMatchGraphicStyleFill = true;	// we found something good														break;													}													//alert( "matched GRADIENT SpotColor fills: " + graphicStyleNames[ii] );												// needed a catch all continue if something else here												}											} 											// alert( "matched GradientColor fills: " + graphicStyleNames[ii] );										} else {											continue;	// eg skip to next for loop without exicuting the next if statements, etc										}									}									if( thisItem.fillColor.typename == "LabColor" && graphicStyleFills[ii].typename == "LabColor" ) {										if( thisItem.fillColor.a 			!= graphicStyleFills[ii].a 												 ||  thisItem.fillColor.b != graphicStyleFills[ii].b 												 ||  thisItem.fillColor.l  != graphicStyleFills[ii].l  										   ) {												continue;	// eg skip to next for loop without exicuting the next if statements, etc										} else {											tempMatchGraphicStyleFill = true;	// we found something good										}										//alert( "matched LabColor fills: " + graphicStyleNames[ii]);									}									if( thisItem.fillColor.typename == "PatternColor" && graphicStyleFills[ii].typename == "PatternColor" ) {										if( thisItem.fillColor.pattern !=graphicStyleFills[ii].pattern  ) {											continue;	// eg skip to next for loop without exicuting the next if statements, etc										} else {											tempMatchGraphicStyleFill = true;	// we found something good										}										//alert( "matched LabColor fills: " + graphicStyleNames[ii] );									}									if( thisItem.fillColor.typename == "SpotColor" && graphicStyleFills[ii].typename == "SpotColor" ) {										if( thisItem.fillColor.spot 		   != graphicStyleFills[ii].spot												 ||  thisItem.fillColor.tint != graphicStyleFills[ii].tint  ) {											continue;	// eg skip to next for loop without exicuting the next if statements, etc										} else {											tempMatchGraphicStyleFill = true;	// we found something good										}										//alert( "matched SpotColor fills: " + graphicStyleNames[ii] );									}									//alert( "matched fills: " + graphicStyleNames[ii] );								}							}							//foundMatch = false;		// this is now explicate in each test						} else if( matchGraphicStyleFill && (thisItem.filled == false && graphicStyleIsFilled[ii] == false)  ) {							tempMatchGraphicStyleFill = true;							} else if( matchGraphicStyleFill == false ) {							tempMatchGraphicStyleFill = true;						// we don't care if we found something good						}												if( matchGraphicStyleStroke && thisItem.stroked ) {							// alert( "got to STROKE test" );							if( thisItem.stroked != graphicStyleIsStroked[ii] ) {								continue;							} else {								//alert( "might have a STROKE match, let's look..." );								if( matchGraphicStyleStrokeColor ) {									if( thisItem.fillColor.typename == "NoColor" && graphicStyleFills[ii].typename == "NoColor" ) {										// Nothing further to test, there is a match										tempMatchGraphicStyleStrokeColor = true;	// we found something good									}																	if( thisItem.strokeColor.typename == "CMYKColor" && graphicStyleStrokeColor[ii].typename == "CMYKColor" ) {										if( 		 thisItem.strokeColor.black 		!= graphicStyleStrokeColor[ii].black 												 ||  thisItem.strokeColor.cyan 		!= graphicStyleStrokeColor[ii].cyan 												 ||  thisItem.strokeColor.magenta != graphicStyleStrokeColor[ii].magenta 												 ||  thisItem.strokeColor.yellow 	!= graphicStyleStrokeColor[ii].yellow  											   ) {												continue;																	// eg skip to next for loop without exicuting the next if statements, etc										} else {											tempMatchGraphicStyleStrokeColor = true;							// we found something good										}										//alert( "matched cmyk strokes: " + graphicStyleNames[ii] );									}									if( thisItem.strokeColor.typename == "RGBColor" && graphicStyleStrokeColor[ii].typename == "RGBColor" ) {										if( 		  thisItem.strokeColor.blue  != graphicStyleStrokeColor[ii].blue 												 ||  thisItem.strokeColor.green != graphicStyleStrokeColor[ii].green 												 ||  thisItem.strokeColor.red    != graphicStyleStrokeColor[ii].red  											   ) {												continue;																		// eg skip to next for loop without exicuting the next if statements, etc										} else {											tempMatchGraphicStyleStrokeColor = true;							// we found something good										}										//alert( "matched rbg strokes: " + graphicStyleNames[ii] );									}									if( thisItem.strokeColor.typename == "GrayColor" && graphicStyleStrokeColor[ii].typename == "GrayColor" ) {										if( thisItem.strokeColor.gray != graphicStyleStrokeColor[ii].gray ) {											continue;																		// eg skip to next for loop without exicuting the next if statements, etc										} else {											tempMatchGraphicStyleStrokeColor = true;							// we found something good										}										//alert( "matched grayscale strokes: " + graphicStyleNames[ii] );									}									// UP to CS3 does not support Gradients on Strokes (while Flash does)									/*if( thisItem.strokeColor.typename == "GradientColor" && graphicStyleStrokeColor[ii].typename == "GradientColor" ) {										if( thisItem.strokeColor.gradient != graphicStyleStrokeColor[ii].gradient ) {											continue;											}										alert( "matched GradientColor strokes: " + graphicStyleNames[ii] );									}*/									if( thisItem.strokeColor.typename == "LabColor" && graphicStyleStrokeColor[ii].typename == "LabColor" ) {										if( thisItem.strokeColor.a != graphicStyleStrokeColor[ii].a 												 || thisItem.strokeColor.b != graphicStyleStrokeColor[ii].b 												 || thisItem.strokeColor.l != graphicStyleStrokeColor[ii].l  										   ) {												continue;	// eg skip to next for loop without exicuting the next if statements, etc										} else {											tempMatchGraphicStyleStrokeColor = true;	// we found something good										}										//alert( "matched LabColor strokes: " + graphicStyleNames[ii]);									}									// UP to CS3 does not support Patterns on Strokes									/*if( thisItem.strokeColor.typename == "PatternColor" && graphicStyleStrokeColor[ii].typename == "PatternColor" ) {										if( thisItem.strokeColor.pattern != graphicStyleStrokeColor[ii].pattern  ) {											continue;										}										alert( "matched LabColor strokes: " + graphicStyleNames[ii] );									}*/									if( thisItem.strokeColor.typename == "SpotColor" && graphicStyleStrokeColor[ii].typename == "SpotColor" ) {										if( thisItem.strokeColor.spot != graphicStyleStrokeColor[ii].spot												 ||  thisItem.strokeColor.tint != graphicStyleStrokeColor[ii].tint  										   ) {												continue;															// eg skip to next for loop without exicuting the next if statements, etc										} else {											tempMatchGraphicStyleStrokeColor = true;				// we found something good										}										//alert( "matched SpotColor strokes: " + graphicStyleNames[ii] );									}									//alert( "matched strokes: " + graphicStyleNames[ii] );								} else if( tempMatchGraphicStyleStrokeColor == false ) {									tempMatchGraphicStyleStrokeColor = true;						// we don't care if we found something good								}															if( matchGraphicStyleStrokeWeight ) {									if( thisItem.strokeWidth != graphicStyleStrokeWeight[ii] ) {										continue;																// eg skip to next for loop without exicuting the next if statements, etc									} else {										tempMatchGraphicStyleStrokeWeight = true;				// we found something good									}								} else if( matchGraphicStyleStrokeWeight == false ) {									tempMatchGraphicStyleStrokeWeight = true;					// we don't care if we found something good								}								if( matchGraphicStyleStrokeDashes ) {									// TODO: null condition detection									if( thisItem.strokeDashes.length > 0 ) {										if( thisItem.strokeDashes.length != graphicStyleDashes[ii].length ) {											continue;																// eg skip to next for loop without exicuting the next if statements, etc										} else {											for( v=0; v<thisItem.strokeDashes.length; v++ ) {												if( thisItem.strokeDashes[v] != graphicStyleDashes[ii][v] ) {													continue;																// eg skip to next for loop without exicuting the next if statements, etc												}												tempMatchGraphicStyleStrokeDashes = true;				// we found something good											}										}									} else {										if( thisItem.strokeDashes.length == 0 && graphicStyleDashes[ii].length == 0 ) {											tempMatchGraphicStyleStrokeDashes = true;					// we found something good										} else {											tempMatchGraphicStyleStrokeDashes = false;				// we didn't find something good										}									}									//alert( "matched stroke dash style: " + graphicStyleNames[ii] );								} else if( matchGraphicStyleStrokeDashes == false ) {									tempMatchGraphicStyleStrokeDashes = true;							// we don't care if we found something good								}							}							if(      tempMatchGraphicStyleStrokeColor 								&& tempMatchGraphicStyleStrokeWeight 								&& tempMatchGraphicStyleStrokeDashes								) {										tempMatchGraphicStyleStroke = true;						// we found something good 							}						} else if( matchGraphicStyleStroke && (thisItem.stroked == false && graphicStyleIsStroked[ii] == false)  ) {							tempMatchGraphicStyleStroke = true;							} else if( matchGraphicStyleStroke == false ) {							tempMatchGraphicStyleStroke = true;						// we don't care if we found something good						}											if( matchGraphicStyleOpacity ) {							if( thisItem.opacity != graphicStyleOpacity[ii] ) {								continue;																		// eg skip to next for loop without exicuting the next if statements, etc							} else {								tempMatchGraphicStyleOpacity = true;								// we found something good							}							//alert( "matched opacities: " + graphicStyleNames[ii] );						} else if( matchGraphicStyleOpacity == false ) {							tempMatchGraphicStyleOpacity = true;									// we don't care if we found something good						}										//alert( "tempMatchGraphicStyleFill:" + tempMatchGraphicStyleFill );						//alert( "tempMatchGraphicStyleStroke: " + tempMatchGraphicStyleStroke );						// alert( " tempMatchGraphicStyleOpacity: " + tempMatchGraphicStyleOpacity );												// if there is a similar graphic style						// then use that instead of the user provided style via styleName												// If we've gotten this far, we've found the style						if(          tempMatchGraphicStyleFill 								&& tempMatchGraphicStyleStroke //								&& tempMatchGraphicStyleStrokeColor  //								&& tempMatchGraphicStyleStrokeWeight //								&& tempMatchGraphicStyleStrokeDashes								&& tempMatchGraphicStyleOpacity										) {									styleName = graphicStyleNames[ii];							// we found the style!									break;																	// and don't need to go any farther						} else {												continue;																		// just to be explicate						}					}							}				// Make sure there is a style by that name				for( j=0; j < numberStyles; j++ ) {					if( doc.graphicStyles[j].name != styleName ) {						continue;					}					if( doc.graphicStyles[j].name == styleName ) {						styleExists = true;						break;					}				}				// WARNING! Just finds the 1st instance of the name, does not check for duplicate style names! 				if ( styleExists ) {						//alert( styleName );					oldStrokeWeight = thisItem.strokeWidth;					if( overrideGraphicStyle ) {						// force the type to be EXACTLY the character style attributes						doc.graphicStyles[styleName].applyTo( thisItem );						if( restoreGraphicStrokeWeight ) {							if( thisItem.strokeWidth != oldStrokeWeight ) {								thisItem.strokeWidth = oldStrokeWeight;							}						}					} else {						// don't clear overrides (kerning, leading, size)						doc.graphicStyles[styleName].mergeTo( thisItem );					}				}			}		}	}}// There is no direct way to access graphic styles, so use this workaround// Creates temporary path item and applies each style to it and records the // fill, stroke, and stroke weightfunction gatherGraphicStyles( ){	var relock = false;	var artLayer = activeDocument.layers[0];	if( doc.layers[0].locked ) { 		doc.layers[0].locked= false;		relock = true;	}		// create temporary path item to stylize	var rect = artLayer.pathItems.rectangle( 762.5, 87.5, 425.0, 75.0 );	// Make sure there is a style by that name	numberStyles = activeDocument.graphicStyles.length;	var tempAlertText = "";	for( j=0; j < numberStyles; j++ ) {		doc.graphicStyles[j].applyTo( rect );		///////		graphicStyleNames.push( doc.graphicStyles[j].name );		graphicStyleIsFilled.push( rect.filled );			graphicStyleFills.push( rect.fillColor );		graphicStyleIsStroked.push( rect.stroked );			graphicStyleStrokeColor.push( rect.strokeColor );		graphicStyleStrokeWeight.push( rect.strokeWidth );		graphicStyleDashes.push( rect.strokeDashes );		graphicStyleOpacity.push( rect.opacity );		//tempAlertText += graphicStyleDashes[j] + " || ";	}	// kill the temp shape	rect.remove();	// if neccesary, relock the drawing layer	if( relock ) { 		doc.layers[0].locked= true;	}	//alert( tempAlertText );}