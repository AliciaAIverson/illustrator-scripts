// The author maintains exclusive rights to the source code and distribution of derivative products/*- * Copyright (c) 2009-2010 Nathaniel Vaughn KELSO @ kelsocartography.com * All rights reserved. * * This code is derived from software contributed to or originating on kelsocartography.com * * The author maintains exclusive rights to the source code and distribution of derivative products * * Redistribution and use in source and binary forms, with or without * modification, are NOT permitted unless the following conditions * are met: * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in the *    documentation and/or other materials provided with the distribution. * 3. All advertising materials mentioning features or use of this software *     must display the following acknowledgement: *        This product includes software developed by kelsocartography.com * 4. Neither the name of kelsocartography.com nor the names of its *    contributors may be used to endorse or promote products derived *    from this software without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY KELSOCARTOGRAPHY.COM AND CONTRIBUTORS * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */// Requested by Nat Case// The script would restyle between delimiter characters // (or between a delimiter and the end of a text block) // according to the number after the delimiter. Then it // would go through and delete the delimiters and the // single character after each one.// EXAMPLE: #1abc#2def#3xyz#// Time total: 11.5 hr// Estimated $200 to $300 script + $50 extra for source code// Adendum for preferences in the $100 to $150 range// 2.5 hours on 5 Jan. 2010// 2 hours on 4 Jan. 2010// 1.5 hours on 3 Jan. 2010// 0.5 hour on 28 Dec. 2009// 1.0 hours on 22 Dec. 2009// 2.0 hours on 20 Dec. 2009 (Sunday) // 1.5 hours on 17 Dec. 2009// 30 minutes prior to 17 Dec 2009////////////////////////////////////////////// Script settings////////////////////////////////////////////var runWithInteraction = "dialog";//var runWithInteraction = "silent";////////////////////////////////////////////// Note: the first element is the "fail" style"var targetCharStyle = new Array(    [0,"[Normal Character Style]"], 										     [0,"[Normal Character Style]"], 											 [0,"[Normal Character Style]"], 											 [0,"[Normal Character Style]"], 											 [0,"[Normal Character Style]"], 											 [0,"[Normal Character Style]"], 											 [0,"[Normal Character Style]"], 											 [0,"[Normal Character Style]"], 											 [0,"[Normal Character Style]"], 											 [0,"[Normal Character Style]"]    );var deliminator = "#";var deliminatorReplacement = "";var tabReturnDelims = new Array();	 tabReturnDelims.push( ["±","\t"], ["‡","\n"], ["∏","\r"] );var addBackDelimOnFail = true;////////////////////////////////////////////var reportResults = false;var failCount = 0;var errorOnCharStyleRemappedPrefs = false;var errorOnCharStylePrefs = false;////////////////////////////////////////////var mySelection = new Array;var theFindingArray = new Array;var theFindMatchedArray = new Array;var theErrorArray = new Array;////////////////////////////////////////////var allTextFrames = new Array;var initialTextFrames = new Array;////////////////////////////////////////////var firstRunX = true;////////////////////////////////////////////var selectResults = false;								// if replaceFontStyling is FALSE then we're just finding so we AUTO set select results = true var selectResultsIfFailedOnly = true;var clearSelectionStatus = true;						// and clearSelectionStatus to true regardless of values given here but if TRUE then these settings will be respeted ////////////////////////////						      	// if BOTH are TRUE, then all objects in the document are processed, else if both False, just the ACTIVE SELECTIONvar examineSelectedOnly = true;					// if true then just the active selection, if false than all objects in document will be evaluated////////////////////////////var myLoc;												// For storing script preferences between use////////////////////////////////////////////////////////// IF text frame contents start and end with ## we want to persue it// Then we want to split based on the #// And capture the charStyle based on the int after the #// Then stylize the text on that new line based on that target styleinit = function() {	timeTrail = checkExpireDate();	timeTrail = true;	if( timeTrail ) {		// now the main logic		if( documents.length > 0 ) {			// is there a text frame to use as the search similar styling?			try {				theSearchOnFrame = null;								examineSelectedOnly = false;								// SET UP DEFAULTS				// IN CASE THERE IS NO SELECTION				if( app.activeDocument.textFrames.length > 0 ) {					allTextFrames = app.activeDocument.textFrames;					initialTextFrames = [];					mySelection = [];				} else {					alert( "Please make sure you have text in your document." );					return false;				}								if( app.activeDocument.selection ) {					if( app.activeDocument.selection.typename == "TextRange" || 						app.activeDocument.selection.typename == "TextFrame" || 						app.activeDocument.selection[0].typename == "TextFrame" // ||						//app.activeDocument.selection.typename == "InsertionPoint"					) {						examineSelectedOnly = true;						if( app.activeDocument.selection.typename == "TextRange" ) {							if( activeDocument.selection.length > 0 ) {								initialTextFrames = app.activeDocument.selection.story.textFrames;								allTextFrames = app.activeDocument.textFrames;							} else {								allTextFrames = app.activeDocument.textFrames;								initialTextFrames = app.activeDocument.selection.parent.textFrames;							}						} else if( app.activeDocument.selection.typename == "TextFrame" ) {							initialTextFrames = app.activeDocument.selection;							allTextFrames = app.activeDocument.textFrames;						} else if( app.activeDocument.selection[0].typename == "TextFrame" ) {							initialTextFrames = app.activeDocument.selection;													allTextFrames = app.activeDocument.textFrames;						}					} else {						alert( "Please select some text objects!" );						return false;					}				}			} catch(e) { 				/*alert( "Problem setting scope: " + e); */ 				//examineSelectedOnly = false;			}								//result = doTheWindow();			switch( runWithInteraction ) {				case "dialog" :					result = readPrefs( Folder.appData+"/stylizeBetweenPreferences.txt" );					//alert( result );					boo = decodePrefsString( result );					doTheSimpleWindow();					break;				case "silent" :					main();					break;				case "none":				default :					processWindow( "FindAll" );					break;			}		} else {			alert( "Open an Illustrator document first and then run this script." );		}	} else {		alert( "Trial period expired. Contact nvkelso@gmail.com to purchase." );	}}main = function( ) {	try{ 				var mySelectionLength = 0;				if( examineSelectedOnly  && initialTextFrames.length > 0 ) {			mySelection = initialTextFrames;			examineSelectedOnlyActual = examineSelectedOnly;		} else {			mySelection = allTextFrames;			examineSelectedOnlyActual = false;		}						mySelectionLength = mySelection.length;		//alert (mySelectionLength);				// Go thru all that document's textItems (might just be the initial text frame selection)		for( k=0; k<mySelectionLength; k++ ) {						thisLayerPageItem = mySelection[k];						// Default, look at it!			theFindingArray[k] = true;						if( examineSelectedOnlyActual && thisLayerPageItem.selected == false  ) {				theFindingArray[k] = false;				continue;			}						if( thisLayerPageItem.hidden == true ) {				theFindingArray[k] = false;				continue;			}						if( thisLayerPageItem.locked == true ) {				theFindingArray[k] = false;				continue;			}					// If the object conditions match...			// Now examine the LAYER conditions			if( theFindingArray[k] == true ) {				if( thisLayerPageItem.layer.parent.typename== "Document") {						if( thisLayerPageItem.layer.hidden ){							// If the object is on a hidden layer and we don't want to find hidden layer's objects							// reset the evaluate of this object back to false							theFindingArray[k] = false;							continue;						}				} else {					if( (thisLayerPageItem.layer.parent.typename == "Layer" ) && 						(thisLayerPageItem.layer.parent.parent.typename== "Document")	) {						if( thisLayerPageItem.layer.hidden || 							thisLayerPageItem.layer.parent.hidden  ){								// If the object is on a hidden layer and we don't want to find hidden layer's objects								// reset the evaluate of this object back to false								theFindingArray[k] = false;								continue;						}					} else {						if( (thisLayerPageItem.layer.parent.typename == "Layer" ) && 							(thisLayerPageItem.layer.parent.parent.typename == "Layer" ) && 							(thisLayerPageItem.layer.parent.parent.parent.typename== "Document")	) {								if( thisLayerPageItem.layer.hidden || 									thisLayerPageItem.layer.parent.hidden || 									thisLayerPageItem.layer.parent.parent.hidden  ){										// If the object is on a hidden layer and we don't want to find hidden layer's objects										// reset the evaluate of this object back to false										theFindingArray[k] = false;										continue;								}						} else {							if( (thisLayerPageItem.layer.parent.typename == "Layer" ) && 								(thisLayerPageItem.layer.parent.parent.typename == "Layer" ) && 								(thisLayerPageItem.layer.parent.parent.parent.typename== "Layer") && 								(thisLayerPageItem.layer.parent.parent.parent.parent.typename== "Document")	) {									if( thisLayerPageItem.layer.hidden || 										thisLayerPageItem.layer.parent.hidden || 										thisLayerPageItem.layer.parent.parent.hidden || 										thisLayerPageItem.layer.parent.parent.parent.hidden  ){											// If the object is on a hidden layer and we don't want to find hidden layer's objects											// reset the evaluate of this object back to false											theFindingArray[k] = false;											continue;									}							} else {								if( (thisLayerPageItem.layer.parent.typename == "Layer" ) && 									(thisLayerPageItem.layer.parent.parent.typename == "Layer" ) && 									(thisLayerPageItem.layer.parent.parent.parent.typename == "Layer" ) && 									(thisLayerPageItem.layer.parent.parent.parent.parent.typename== "Layer") && 									(thisLayerPageItem.layer.parent.parent.parent.parent.parent.typename== "Document")	) {										if( thisLayerPageItem.layer.hidden || 											thisLayerPageItem.layer.parent.hidden || 											thisLayerPageItem.layer.parent.parent.hidden || 											thisLayerPageItem.layer.parent.parent.parent.hidden || 											thisLayerPageItem.layer.parent.parent.parent.parent.hidden ){												// If the object is on a hidden layer and we don't want to find hidden layer's objects												// reset the evaluate of this object back to false												theFindingArray[k] = false;												continue;										}								} else {									// Only support top-level layers so many levels deep!									theFindingArray[k] = false;									continue;								}							}						}					}				}			}			if( theFindingArray[k]  == true ) {				if( thisLayerPageItem.layer.parent.typename== "Document") {						if( thisLayerPageItem.layer.locked ){							// If the object is on a hidden layer and we don't want to find hidden layer's objects							// reset the evaluate of this object back to false							theFindingArray[k] = false;							continue;						}				} else {					if( (thisLayerPageItem.layer.parent.typename == "Layer" ) && 						(thisLayerPageItem.layer.parent.parent.typename== "Document")	) {						if( thisLayerPageItem.layer.locked || 							thisLayerPageItem.layer.parent.locked  ){								// If the object is on a hidden layer and we don't want to find hidden layer's objects								// reset the evaluate of this object back to false								theFindingArray[k] = false;								continue;						}					} else {						if( (thisLayerPageItem.layer.parent.typename == "Layer" ) && 							(thisLayerPageItem.layer.parent.parent.typename == "Layer" ) && 							(thisLayerPageItem.layer.parent.parent.parent.typename== "Document")	) {								if( thisLayerPageItem.layer.locked || 									thisLayerPageItem.layer.parent.locked || 									thisLayerPageItem.layer.parent.parent.locked  ){										// If the object is on a hidden layer and we don't want to find hidden layer's objects										// reset the evaluate of this object back to false										theFindingArray[k] = false;										continue;								}						} else {							if( (thisLayerPageItem.layer.parent.typename == "Layer" ) && 								(thisLayerPageItem.layer.parent.parent.typename == "Layer" ) && 								(thisLayerPageItem.layer.parent.parent.parent.typename== "Layer") && 								(thisLayerPageItem.layer.parent.parent.parent.parent.typename== "Document")	) {									if( thisLayerPageItem.layer.locked || 										thisLayerPageItem.layer.parent.locked || 										thisLayerPageItem.layer.parent.parent.locked || 										thisLayerPageItem.layer.parent.parent.parent.locked  ){											// If the object is on a hidden layer and we don't want to find hidden layer's objects											// reset the evaluate of this object back to false											theFindingArray[k] = false;											continue;									}							} else {								if( (thisLayerPageItem.layer.parent.typename == "Layer" ) && 									(thisLayerPageItem.layer.parent.parent.typename == "Layer" ) && 									(thisLayerPageItem.layer.parent.parent.parent.typename == "Layer" ) && 									(thisLayerPageItem.layer.parent.parent.parent.parent.typename== "Layer") && 									(thisLayerPageItem.layer.parent.parent.parent.parent.parent.typename== "Document")	) {										if( thisLayerPageItem.layer.locked || 											thisLayerPageItem.layer.parent.locked || 											thisLayerPageItem.layer.parent.parent.locked || 											thisLayerPageItem.layer.parent.parent.parent.locked || 											thisLayerPageItem.layer.parent.parent.parent.parent.locked ){												// If the object is on a hidden layer and we don't want to find hidden layer's objects												// reset the evaluate of this object back to false												theFindingArray[k] = false;												continue;										}								} else {									// Only support top-level layers so many levels deep!									theFindingArray[k] = false;									continue;								}							}						}					}				}			}		}	} catch(e) { alert( "there was an error in the main function" + e ); }	// for pacing of the script timing	result = doTheFindMatchingLooping();		if( reportResults ) {		if( failCount > 0 ) {			alert( result + " met the conditions but " + failCount + " failed with errors.\nOnly the failed items are selected." );		} else {			alert( result + " met the conditions.\nSuccessfully styled text items have been selected." );		}	} else if( failCount > 0 ) {		alert( result + " met the conditions but " + failCount + " failed with errors.\nOnly the failed items are selected." );	}}doTheFindMatchingLooping = function( ) {	try{						var endIndex = theFindingArray.length - 1;		var matchExists = false;		var howManyMatches = 0;						// make sure there are items to process!		if( endIndex >= 0 ) {			// BEGIN TEXT FRAME LOOP			for ( i = 0; i <= endIndex; i++ ) {				// BEGIN TEXT FRAME LOOP				if( theFindingArray[i] == false ) {					//alert( "we shouldn't exmaine this one" );					theFindMatchedArray[i] = false;					theErrorArray[i] = false;				} else {					//alert( "we got into the finding loop!" );					thisTextFrame = mySelection[i];					itMatches = false;										// Don't search thru null text frames					// Must at least have form  #1c#					if( thisTextFrame.textRanges.length > 3 ) {											////////////////////////////////////////////						// START -- Prep the object to be modifieds						////////////////////////////////////////////												// was already deselected at top as appropriate						if( clearSelectionStatus ) {							thisTextFrame.selected = false;						}											////////////////////////////////////////////						// END Prep the object to be modifieds						////////////////////////////////////////////												// Zero out the array tracker						theFindMatchedArray[i] = false;																		itMatches = doTheFindMatching( i );												if( itMatches ) {							theFindMatchedArray[i] = true;							howManyMatches++;							}					}				}			}		}				// Do the selection states		endIndex = theErrorArray.length;		if( failCount > 0 && selectResultsIfFailedOnly ) {			for ( i = 0; i < endIndex; i++ ) {				if( theErrorArray[i] ) {					mySelection[i].selected = true;				} else {					mySelection[i].selected = false;				}			}		} else {			if( selectResults ) {				for ( i = 0; i < endIndex; i++ ) {					if( theFindMatchedArray[i] ) {						mySelection[i].selected = true;					}  else {						mySelection[i].selected = false;					}				}			}		}			return howManyMatches;	} catch(e) { alert( "in do the find matching looping: " + e ); }}doTheFindMatching = function( parentTextFrameNumber  ) {	matchExists = false;	try{ 		parentTextFrame = mySelection[ parentTextFrameNumber ];				firstItem = mySelection[ parentTextFrameNumber ].characters[ 0 ];		secondItem = mySelection[ parentTextFrameNumber ].characters[ 1 ];		lastItem = mySelection[ parentTextFrameNumber ].characters[ mySelection[ parentTextFrameNumber ].characters.length - 1 ];				var targetText = "";						if( firstItem.contents == deliminator && lastItem.contents == deliminator ) {			// Our initial conditions are met			// Now attempt to split on # and test for first char after the # deliminators being a number.			// If it is, apply the same charStyle to it						targetText = parentTextFrame.contents;						var intIndexOfMatch;						for( var a = 0; a<tabReturnDelims.length; a++ ) {				if( tabReturnDelims[a] != "" ) {					intIndexOfMatch = targetText.indexOf( tabReturnDelims[a][0] );									// Loop over the string value replacing out each matching substring.					while (intIndexOfMatch != -1){						targetText = targetText.replace( tabReturnDelims[a][0], tabReturnDelims[a][1] )						// Get the index of any next matching substring.						intIndexOfMatch = targetText.indexOf( tabReturnDelims[a][0] );					}				}			}						var sectionsArray = targetText.split( deliminator );			var masterTextRanges = parentTextFrame.textRange.characters;				 parentTextFrame.textRange.contents = "";				 			var startIndex = 0;			var endIndex = 0;			var applyStyleFailed = false;			var b = 0;						for( a = 0; a<sectionsArray.length; a++ ) {				applyStyleFailed = true;								if( sectionsArray[a].length > 0 ) {					//thisRange = new TextRange();					thisRange = sectionsArray[a];										if(isNaN( thisRange[0] ) == false ) {						charStyle = parseInt( thisRange[0] );						if( charStyle < targetCharStyle.length ) {							// Kill the style reference number							thisRange = thisRange.substring( 1 );														// Make sure that sytle is available							if( (targetCharStyle[charStyle][0] < app.activeDocument.characterStyles.length) &&  								(targetCharStyle[charStyle][0] >= 0) ) 							{								theReplacingCharStyleStyleObj = app.activeDocument.characterStyles[ targetCharStyle[charStyle][0] ];																startIndex = masterTextRanges.length;								masterTextRanges.add( thisRange );								endIndex = masterTextRanges.length;																for( b = startIndex; b<endIndex; b++ ) { 									// force the type to be EXACTLY the character style attributes										theReplacingCharStyleStyleObj.applyTo( masterTextRanges[b], true );								}															matchExists = true;								applyStyleFailed = false;							} 						}					}					if( applyStyleFailed ) {											// Make normal "unstyled" text						if( (targetCharStyle[0][0] < app.activeDocument.characterStyles.length) &&  							(targetCharStyle[0][0] >= 0) ) 						{							theReplacingCharStyleStyleObj = app.activeDocument.characterStyles[ targetCharStyle[0][0] ];						} else {							theReplacingCharStyleStyleObj = app.activeDocument.characterStyles[ 0 ];						}												startIndex = masterTextRanges.length;						if( addBackDelimOnFail ) {							temp = (deliminator + thisRange + deliminator);						} else {							temp = thisRange;						}						masterTextRanges.add( temp );						endIndex = masterTextRanges.length;						for( b = startIndex; b<endIndex; b++ ) { 							// force the type to be EXACTLY the character style attributes								theReplacingCharStyleStyleObj.applyTo( masterTextRanges[b], true );						}						failCount++;						theErrorArray[ parentTextFrameNumber ] = true;						} else {						theErrorArray[ parentTextFrameNumber ] = false;					}				}			}		}	} catch(e) {alert(e); }		return matchExists;}doTheSimpleWindow = function() {	resSimple = "dialog { \		alignment: 'left', \		text: 'Stylize text...',\		properties:{ closeButton: true }, \		s01: StaticText { alignment: 'left',text:'Use this script to format text that has nested styles within delimiters.' }, \		s02: StaticText { alignment: 'left',text:'Example: #1abc#2def#3xyz#' }, \		s03: StaticText { alignment: 'left',text:'Here # is the delimiter and the number after the # indicates the character style to use.' }, \		delimValue: Group{ orientation: 'row', \			alignment: 'left', \			s1: StaticText { text:'Delimiter:' }, \			e1: EditText { preferredSize: [40, 20] } \			s2: StaticText { text:'Will be deleted from output.' }, \		},\		charStyles: Group{ orientation: 'row', \			alignment: 'left', \			pairings: Panel { orientation: 'column', alignChildren:'left', \				alignment: 'left', \				delim1: Group{ orientation: 'row', \					alignment: 'right', \					s: StaticText { text:'1st style:' }, \					d: DropDownList { preferredSize:  [188, 20] }, \				},\				delim2: Group{ orientation: 'row', \					alignment: 'right', \					s: StaticText { text:'2nd style:' }, \					d: DropDownList { preferredSize:  [188, 20] }, \				},\				delim3: Group{ orientation: 'row', \					alignment: 'right', \					s: StaticText { text:'3rd style:' }, \					d: DropDownList { preferredSize:  [188, 20] }, \				},\				delim4: Group{ orientation: 'row', \					alignment: 'right', \					s: StaticText { text:'4th style:' }, \					d: DropDownList { preferredSize:  [188, 20] }, \				},\				delim5: Group{ orientation: 'row', \					alignment: 'right', \					s: StaticText { text:'5th style:' }, \					d: DropDownList { preferredSize:  [188, 20] }, \				},\				delim6: Group{ orientation: 'row', \					alignment: 'right', \					s: StaticText { text:'6th style:' }, \					d: DropDownList { preferredSize:  [188, 20] }, \				},\				delim7: Group{ orientation: 'row', \					alignment: 'right', \					s: StaticText { text:'7th style:' }, \					d: DropDownList { preferredSize:  [188, 20] }, \				},\				delim8: Group{ orientation: 'row', \					alignment: 'right', \					s: StaticText { text:'8th style:' }, \					d: DropDownList { preferredSize:  [188, 20] }, \				},\				delim9: Group{ orientation: 'row', \					alignment: 'right', \					s: StaticText { text:'9th style:' }, \					d: DropDownList { preferredSize:  [188, 20] }, \				},\				delim0: Group{ orientation: 'row', \					alignment: 'right', \					s: StaticText { text:'Fail style:' }, \					d: DropDownList { preferredSize:  [188, 20] }, \				},\			}, \			charStyleOptions: Group{ orientation: 'column', \				alignment: 'top', \				guess: Button { text:'Guess', maximumSize:[60, 20], properties:{name:'Guess'} } \				reset: Button { text:'Reset', maximumSize:[60, 20], properties:{name:'Reset'} }, \			}, \		}, \		options: Panel { orientation: 'column', alignChildren:'left', \			alignment: 'left', \			s0: StaticText { text:'Special delimiters can be used to reflow the text. Example: ± gets replaced with tab.' }, \			delim0: Group{ orientation: 'row', \				s1: StaticText { text:'Replace:' }, \				e1: EditText { preferredSize: [40, 20] }, \				s2: StaticText { text:'with:' }, \				d1: DropDownList { preferredSize:  [188, 20] }, \				s3: StaticText { text:'Example: ±' }, \			},\			delim1: Group{ orientation: 'row', \				s1: StaticText { text:'Replace:' }, \				e1: EditText { preferredSize: [40, 20] }, \				s2: StaticText { text:'with:' }, \				d1: DropDownList { preferredSize:  [188, 20] }, \				s3: StaticText { text:'Example: ‡' }, \			},\			delim2: Group{ orientation: 'row', \				s1: StaticText { text:'Replace:' }, \				e1: EditText { preferredSize: [40, 20] }, \				s2: StaticText { text:'with:' }, \				d1: DropDownList { preferredSize:  [188, 20] }, \				s3: StaticText { text:'Example: ∏' }, \			},\		},\		results: Panel { orientation: 'row', alignChildren:'left', \			errorReporting: Checkbox{ text:'Report errors'},\			alwaysReport: Checkbox{ text:'Always report results'},\		},\		buttons: Group { orientation: 'row', \			alignment: 'center', \			resetToDefaults: Button { text:'Restore defaults', maximumSize:[120, 20], properties:{name:'defaults'} } \			cancelBtn: Button { text:'Cancel', maximumSize:[60, 20], properties:{name:'cancel'} } \			okBtn: Button { text:'OK', maximumSize:[60, 20], properties:{name:'findAll'} }, \		}, \		copyright: Group { orientation: 'row', \			alignment: 'center', \			s1: StaticText { text:'Copyright (c) 2009 Nathaniel Vaughn KELSO @ kelsocartography.com' }, \		} \	}";		win = new Window (resSimple);		win.delimValue.e1.text = deliminator;		win.delimValue.e1.onChange = function () {		if( win.delimValue.e1.text == "" || win.delimValue.e1.text == null ) {			alert( "Please use a single character delimiter, setting back to last value." );			win.delimValue.e1.text = deliminator;		} else {			deliminator = String( win.delimValue.e1.text );		}	};		// populate the character styles list	numberStyles = app.activeDocument.characterStyles.length;	var tempCharStyle = "";	var shouldAddCharStyle;		for( a=0; a < numberStyles; a++ ) {		tempCharStyle = app.activeDocument.characterStyles[a].name;		shouldAddCharStyle = win.charStyles.pairings.delim1.d.find( tempCharStyle );		// if it should be added to the list, add it		if( shouldAddCharStyle == null ) {			win.charStyles.pairings.delim1.d.add ('item', app.activeDocument.characterStyles[a].name );			win.charStyles.pairings.delim2.d.add ('item', app.activeDocument.characterStyles[a].name );			win.charStyles.pairings.delim3.d.add ('item', app.activeDocument.characterStyles[a].name );			win.charStyles.pairings.delim4.d.add ('item', app.activeDocument.characterStyles[a].name );			win.charStyles.pairings.delim5.d.add ('item', app.activeDocument.characterStyles[a].name );			win.charStyles.pairings.delim6.d.add ('item', app.activeDocument.characterStyles[a].name );			win.charStyles.pairings.delim7.d.add ('item', app.activeDocument.characterStyles[a].name );			win.charStyles.pairings.delim8.d.add ('item', app.activeDocument.characterStyles[a].name );			win.charStyles.pairings.delim9.d.add ('item', app.activeDocument.characterStyles[a].name );			win.charStyles.pairings.delim0.d.add ('item', app.activeDocument.characterStyles[a].name );		}	}		numberStyles = app.activeDocument.characterStyles.length;	for( a=0; a < 10; a++ ) {		valid = false;		// Case where there is a 1:1 match between the character styles we're targeting and the character styles available		if( targetCharStyle[ a ][0] < app.activeDocument.characterStyles.length ) {			if( String(app.activeDocument.characterStyles[ targetCharStyle[ a ][0] ].name) == targetCharStyle[ a ][1] ) {				win.charStyles.pairings[ "delim" + a].d.items[ targetCharStyle[ a ][0] ].selected = true;				valid = true;			}		} 				// We must be in a different or changed document so try to map to new style		if( valid == false ) {			// Look for close matches based on the stored name of the style			for( j=0; j < numberStyles; j++ ) {				if( String(app.activeDocument.characterStyles[j].name) == targetCharStyle[ j ][1] ) {					win.charStyles.pairings[ "delim" + a].d.items[ j ].selected = true;					errorOnCharStyleRemappedPrefs = true;					valid = true;					break;				}			}		}				// If we still didn't find it, let the user know		if( valid == false ) {			errorOnCharStylePrefs = true;		}	}	if( errorOnCharStylePrefs ) { alert( "Some character styles are no longer available, using defaults.\nThis can be caused by running the script in a new document with a different sets of character styles than the prior document.\n\nPlease review your settings to ensure the desired results." ); }	if( errorOnCharStyleRemappedPrefs && reportResults ) { alert( "Some character styles have been remapped.\nThis can be caused by running the script in a new document with a different sets of character styles than the prior document.\n\nPlease review your settings to ensure the desired results." ); }	win.charStyles.charStyleOptions.guess.onClick = function () { 		numberStyles = app.activeDocument.characterStyles.length;				for( a=1; a < numberStyles; a++ ) {			win.charStyles.pairings[ "delim" + a].d.items[ a ].selected = true;		}		win.charStyles.pairings[ "delim" + 0].d.items[ 0 ].selected = true;	};	win.charStyles.charStyleOptions.reset.onClick = function () { 		for( a=0; a < 10; a++ ) {			win.charStyles.pairings[ "delim" + a].d.items[ 0 ].selected = true;		}	};	///////////////////////////////////////////	// Character style events	///////////////////////////////////////////	win.charStyles.pairings.delim0.d.onChange = function () {		replaceCharStyleFontCharStyle = win.charStyles.pairings.delim0.d.selection.toString();		if( replaceCharStyleFontCharStyle != "" ) {			numberStyles = app.activeDocument.characterStyles.length;			for( j=0; j < numberStyles; j++ ) {				if( String(app.activeDocument.characterStyles[j].name) == replaceCharStyleFontCharStyle ) {					targetCharStyle[0][0] = j;					targetCharStyle[0][1] = String(app.activeDocument.characterStyles[j].name);				}			}		}	};	win.charStyles.pairings.delim1.d.onChange = function () {		replaceCharStyleFontCharStyle = win.charStyles.pairings.delim1.d.selection.toString();		if( replaceCharStyleFontCharStyle != "" ) {			numberStyles = app.activeDocument.characterStyles.length;			for( j=0; j < numberStyles; j++ ) {				if( String(app.activeDocument.characterStyles[j].name) == replaceCharStyleFontCharStyle ) {					targetCharStyle[1][0] = j;					targetCharStyle[1][1] = String(app.activeDocument.characterStyles[j].name);				}			}		}	};	win.charStyles.pairings.delim2.d.onChange = function () {		replaceCharStyleFontCharStyle = win.charStyles.pairings.delim2.d.selection.toString();		if( replaceCharStyleFontCharStyle != "" ) {			numberStyles = app.activeDocument.characterStyles.length;			for( j=0; j < numberStyles; j++ ) {				if( String(app.activeDocument.characterStyles[j].name) == replaceCharStyleFontCharStyle ) {					targetCharStyle[2][0] = j;					targetCharStyle[2][1] = String(app.activeDocument.characterStyles[j].name);				}			}		}	};	win.charStyles.pairings.delim3.d.onChange = function () {		replaceCharStyleFontCharStyle = win.charStyles.pairings.delim3.d.selection.toString();		if( replaceCharStyleFontCharStyle != "" ) {			numberStyles = app.activeDocument.characterStyles.length;			for( j=0; j < numberStyles; j++ ) {				if( String(app.activeDocument.characterStyles[j].name) == replaceCharStyleFontCharStyle ) {					targetCharStyle[3][0] = j;					targetCharStyle[3][1] = String(app.activeDocument.characterStyles[j].name);				}			}		}	};	win.charStyles.pairings.delim4.d.onChange = function () {		replaceCharStyleFontCharStyle = win.charStyles.pairings.delim4.d.selection.toString();		if( replaceCharStyleFontCharStyle != "" ) {			numberStyles = app.activeDocument.characterStyles.length;			for( j=0; j < numberStyles; j++ ) {				if( String(app.activeDocument.characterStyles[j].name) == replaceCharStyleFontCharStyle ) {					targetCharStyle[4][0] = j;					targetCharStyle[4][1] = String(app.activeDocument.characterStyles[j].name);				}			}		}	};	win.charStyles.pairings.delim5.d.onChange = function () {		replaceCharStyleFontCharStyle = win.charStyles.pairings.delim5.d.selection.toString();		if( replaceCharStyleFontCharStyle != "" ) {			numberStyles = app.activeDocument.characterStyles.length;			for( j=0; j < numberStyles; j++ ) {				if( String(app.activeDocument.characterStyles[j].name) == replaceCharStyleFontCharStyle ) {					targetCharStyle[5][0] = j;					targetCharStyle[5][1] = String(app.activeDocument.characterStyles[j].name);				}			}		}	};	win.charStyles.pairings.delim6.d.onChange = function () {		replaceCharStyleFontCharStyle = win.charStyles.pairings.delim6.d.selection.toString();		if( replaceCharStyleFontCharStyle != "" ) {			numberStyles = app.activeDocument.characterStyles.length;			for( j=0; j < numberStyles; j++ ) {				if( String(app.activeDocument.characterStyles[j].name) == replaceCharStyleFontCharStyle ) {					targetCharStyle[6][0] = j;					targetCharStyle[6][1] = String(app.activeDocument.characterStyles[j].name);				}			}		}	};	win.charStyles.pairings.delim7.d.onChange = function () {		replaceCharStyleFontCharStyle = win.charStyles.pairings.delim7.d.selection.toString();		if( replaceCharStyleFontCharStyle != "" ) {			numberStyles = app.activeDocument.characterStyles.length;			for( j=0; j < numberStyles; j++ ) {				if( String(app.activeDocument.characterStyles[j].name) == replaceCharStyleFontCharStyle ) {					targetCharStyle[7][0] = j;					targetCharStyle[7][1] = String(app.activeDocument.characterStyles[j].name);				}			}		}	};	win.charStyles.pairings.delim8.d.onChange = function () {		replaceCharStyleFontCharStyle = win.charStyles.pairings.delim8.d.selection.toString();		if( replaceCharStyleFontCharStyle != "" ) {			numberStyles = app.activeDocument.characterStyles.length;			for( j=0; j < numberStyles; j++ ) {				if( String(app.activeDocument.characterStyles[j].name) == replaceCharStyleFontCharStyle ) {					targetCharStyle[8][0] = j;					targetCharStyle[8][1] = String(app.activeDocument.characterStyles[j].name);				}			}		}	};	win.charStyles.pairings.delim9.d.onChange = function () {		replaceCharStyleFontCharStyle = win.charStyles.pairings.delim9.d.selection.toString();		if( replaceCharStyleFontCharStyle != "" ) {			numberStyles = app.activeDocument.characterStyles.length;			for( j=0; j < numberStyles; j++ ) {				if( String(app.activeDocument.characterStyles[j].name) == replaceCharStyleFontCharStyle ) {					targetCharStyle[9][0] = j;					targetCharStyle[9][1] = String(app.activeDocument.characterStyles[j].name);				}			}		}	};	///////////////////////////////////////////	// Find-replace options	///////////////////////////////////////////	win.options.delim0.e1.text = tabReturnDelims[0][0];		win.options.delim0.d1.add ('item', 'Remove (delete)');	win.options.delim0.d1.add ('item', 'Tab');	win.options.delim0.d1.add ('item', 'New line');	win.options.delim0.d1.add ('item', 'New paragraph');	switch( tabReturnDelims[0][1] ) {		case "":			win.options.delim0.d1.items[0].selected = true;			break;		case "\t":			win.options.delim0.d1.items[1].selected = true;			break;		case "\n":			win.options.delim0.d1.items[2].selected = true;			break;		case "\r":			win.options.delim0.d1.items[3].selected = true;			break;		default :			win.options.delim0.d1.items[1].selected = true;		//	}	win.options.delim1.d1.add ('item', 'Remove (delete)');	win.options.delim1.e1.text = tabReturnDelims[1][0];		win.options.delim1.d1.add ('item', 'Tab');	win.options.delim1.d1.add ('item', 'New line');	win.options.delim1.d1.add ('item', 'New paragraph');	switch( tabReturnDelims[1][1] ) {		case "":			win.options.delim1.d1.items[0].selected = true;			break;		case "\t":			win.options.delim1.d1.items[1].selected = true;			break;		case "\n":			win.options.delim1.d1.items[2].selected = true;			break;		case "\r":			win.options.delim1.d1.items[3].selected = true;			break;		default :			win.options.delim1.d1.items[2].selected = true;		//	}		win.options.delim2.d1.add ('item', 'Remove (delete)');	win.options.delim2.e1.text = tabReturnDelims[2][0];	win.options.delim2.d1.add ('item', 'Tab');	win.options.delim2.d1.add ('item', 'New line');	win.options.delim2.d1.add ('item', 'New paragraph');	switch( tabReturnDelims[2][1] ) {		case "":			win.options.delim2.d1.items[0].selected = true;			break;		case "\t":			win.options.delim2.d1.items[1].selected = true;			break;		case "\n":			win.options.delim2.d1.items[2].selected = true;			break;		case "\r":			win.options.delim2.d1.items[3].selected = true;			break;		default :			win.options.delim2.d1.items[3].selected = true;		//	}		win.options.delim0.e1.onChange = function () {		if( deliminator != win.options.delim0.e1.text ) {			if( win.options.delim0.e1.text == "" || win.options.delim0.e1.text == null ) {				tabReturnDelims[0][0] = "";			} else {				tabReturnDelims[0][0] = String( win.options.delim0.e1.text );			}		} else {			alert( "Please use a different value than the main delimiter" );			win.options.delim0.e1.text = tabReturnDelims[0][0];		}	};	win.options.delim1.e1.onChange = function () {		if( deliminator != win.options.delim1.e1.text ) {			if( win.options.delim1.e1.text == "" || win.options.delim1.e1.text == null ) {				tabReturnDelims[1][0] = "";			} else {				tabReturnDelims[1][0] = String( win.options.delim1.e1.text );			}		} else {			alert( "Please use a different value than the main delimiter" );			win.options.delim0.e1.text = tabReturnDelims[1][0];		}	};	win.options.delim2.e1.onChange = function () {		if( deliminator != win.options.delim2.e1.text ) {			if( win.options.delim2.e1.text == "" || win.options.delim2.e1.text == null ) {				tabReturnDelims[2][0] = "";			} else {				tabReturnDelims[2][0] = String( win.options.delim2.e1.text );			}		} else {			alert( "Please use a different value than the main delimiter" );			win.options.delim0.e1.text = tabReturnDelims[2][0];		}	};	win.options.delim0.d1.onChange = function () {		whatToDo = win.options.delim2.d1.selection.toString();		switch( whatToDo ) {			case "Remove (delete)":				tabReturnDelims[0][1] = "";				break;			case "Tab":				tabReturnDelims[0][1] = "\t";				break;			case "New line":				tabReturnDelims[0][1] = "\n";				break;			case "New paragraph":				tabReturnDelims[0][1] = "\r";				break;			//		}	};	win.options.delim1.d1.onChange = function () {		whatToDo = win.options.delim1.d1.selection.toString();		switch( whatToDo ) {			case "Remove (delete)":				tabReturnDelims[1][1] = "";				break;			case "Tab":				tabReturnDelims[1][1] = "\t";				break;			case "New line":				tabReturnDelims[1][1] = "\n";				break;			case "New paragraph":				tabReturnDelims[1][1] = "\r";				break;			//		}	};		win.options.delim2.d1.onChange = function () {		whatToDo = win.options.delim2.d1.selection.toString();		switch( whatToDo ) {			case "Remove (delete)":				tabReturnDelims[2][1] = "";				break;			case "Tab":				tabReturnDelims[2][1] = "\t";				break;			case "New line":				tabReturnDelims[2][1] = "\n";				break;			case "New paragraph":				tabReturnDelims[2][1] = "\r";				break;			//		}	};		///////////////////////////////////////////	// Results options	///////////////////////////////////////////		if( selectResultsIfFailedOnly ) {		win.results.errorReporting.value= true;	} else {		win.results.errorReporting.value= false;	}	win.results.errorReporting.onClick = function () {		if(win.results.errorReporting.value== true) {			selectResultsIfFailedOnly = true;		} else {			selectResultsIfFailedOnly = false;		}	};	if( reportResults ) {		win.results.alwaysReport.value= true;	} else {		win.results.alwaysReport.value= false;	}	win.results.alwaysReport.onClick = function () {		if(win.results.alwaysReport.value== true) {			reportResults = true;		} else {			reportResults = false;		}	};	// The Build and Cancel buttons close this dialog	win.buttons.okBtn.onClick = function () { this.parent.parent.close(1); processWindow("FindAll"); };	win.buttons.cancelBtn.onClick = function () { this.parent.parent.close(0); processWindow("Close");};		win.buttons.resetToDefaults.onClick = function () { 		win.delimValue.e1.text = "#";		win.delimValue.e1.onChange();				for( a=0; a < numberStyles; a++ ) {			win.charStyles.pairings[ "delim" + a].d.items[ 0 ].selected = true;			win.charStyles.pairings[ "delim" + a].d.onChange();		}			win.options.delim0.e1.text = "±";		win.options.delim1.e1.text = "‡";		win.options.delim2.e1.text = "∏";		win.options.delim0.e1.onChange();		win.options.delim1.e1.onChange();		win.options.delim2.e1.onChange();		win.options.delim0.d1.items[1].selected = true;		win.options.delim1.d1.items[2].selected = true;		win.options.delim2.d1.items[3].selected = true;		win.options.delim0.d1.items[1].onChange();		win.options.delim1.d1.items[2].onChange();		win.options.delim2.d1.items[3].onChange();				win.results.errorReporting.value= true;		win.results.alwaysReport.value= false;		win.results.errorReporting.onClick();		win.results.alwaysReport.onClick();	};	win.center();	win.show();}function processWindow( resultMethod ) {		storePrefsPrep();			switch( resultMethod ) {		case "Close" :			// Big woop			break;		case "FindAll" :			main();			break;		//	}}function storePrefsPrep() {	//alert( "Saving the prefs..." );	try {		// do the hard stuff...		var loc = getServerLoc();		myLoc = new File(loc);				if(myLoc.exists){			prefsFile = File(loc );			if(prefsFile.exists){				//do nothing				//alert("Folder '"+myDate+"' already Exists!");			}else{				//alert("Creating new folder at "+loc);				prefsFile.create();			}			var prefsFileName = "stylizeBetweenPreferences.txt";						fileName = File(prefsFile+"\\"+prefsFileName);									storePrefsActual( buildPrefsString() );		} else {			alert( "Failed to create prefs file!" );		}	} catch (e) {		alert("Behold! Your Tomfoolery below:\n\n"+e);	}}function buildPrefsString() {	myPrefString = "";	// 0, 1	myPrefString += targetCharStyle[0][0] + "?" + targetCharStyle[0][1];	// 2, 3	myPrefString += "?" + targetCharStyle[1][0] + "?" + targetCharStyle[1][1];	// 4, 5	myPrefString += "?" + targetCharStyle[2][0] + "?" + targetCharStyle[2][1];	// 6, 7	myPrefString += "?" + targetCharStyle[3][0] + "?" + targetCharStyle[3][1];	// 8, 9	myPrefString += "?" + targetCharStyle[4][0] + "?" + targetCharStyle[4][1];	// 10, 11	myPrefString += "?" + targetCharStyle[5][0] + "?" + targetCharStyle[5][1];	// 12, 13	myPrefString += "?" + targetCharStyle[6][0] + "?" + targetCharStyle[6][1];	// 14, 15	myPrefString += "?" + targetCharStyle[7][0] + "?" + targetCharStyle[7][1];	// 16, 17	myPrefString += "?" + targetCharStyle[8][0] + "?" + targetCharStyle[8][1];	// 18, 19	myPrefString += "?" + targetCharStyle[9][0] + "?" + targetCharStyle[9][1];	// 20	myPrefString += "?" + deliminator;	// 21	myPrefString += "?" + deliminatorReplacement;	// 22, 23	temp = -1;	switch( tabReturnDelims[0][1] ) {		case "":			temp = 0;			break;		case "\t" :			temp = 1;			break;		case "\n" :			temp = 2;			break;		case "\r" :			temp = 3;			break;		//	}	myPrefString += "?" + tabReturnDelims[0][0] + "?" + temp;	// 24, 25	temp = -1;	switch( tabReturnDelims[1][1] ) {		case "":			temp = 0;			break;		case "\t" :			temp = 1;			break;		case "\n" :			temp = 2;			break;		case "\r" :			temp = 3;			break;		//	}	myPrefString += "?" + tabReturnDelims[1][0] + "?" + temp;	// 26, 27	temp = -1;	switch( tabReturnDelims[2][1] ) {		case "":			temp = 0;			break;		case "\t" :			temp = 1;			break;		case "\n" :			temp = 2;			break;		case "\r" :			temp = 3;			break;		//	}	myPrefString += "?" + tabReturnDelims[2][0] + "?" + temp;	// 28	myPrefString += "?" + addBackDelimOnFail;	////////////////////////////////////////////	// 29	myPrefString += "?" + reportResults;	////////////////////////////////////////////	// 30	myPrefString += "?" + selectResults;								// if replaceFontStyling is FALSE then we're just finding so we AUTO set select results = true 	// 31	myPrefString += "?" + selectResultsIfFailedOnly;	// 32	myPrefString += "?" + clearSelectionStatus;						// and clearSelectionStatus to true regardless of values given here but if TRUE then these settings will be respeted 	////////////////////////////						      	// if BOTH are TRUE, then all objects in the document are processed, else if both False, just the ACTIVE SELECTION	// 33	myPrefString += "?" + examineSelectedOnly;		return myPrefString;}function decodePrefsString( myPrefsString ) {	myPrefArray = myPrefsString.split("?");			if( myPrefArray.length == 34 ) {		// 0, 1		targetCharStyle[0][0] = myPrefArray[0]; 		targetCharStyle[0][1] = myPrefArray[1];		// 2, 3		targetCharStyle[1][0] = myPrefArray[2];		targetCharStyle[1][1] = myPrefArray[3];;		// 4, 5		targetCharStyle[2][0] = myPrefArray[4];		targetCharStyle[2][1] = myPrefArray[5];		// 6, 7		targetCharStyle[3][0] = myPrefArray[6];		targetCharStyle[3][1] = myPrefArray[7];		// 8, 9		targetCharStyle[4][0] = myPrefArray[8];		targetCharStyle[4][1] = myPrefArray[9];		// 10, 11		targetCharStyle[5][0] = myPrefArray[10];		targetCharStyle[5][1] = myPrefArray[11];		// 12, 13		targetCharStyle[6][0] = myPrefArray[12];		targetCharStyle[6][1] = myPrefArray[13];;		// 14, 15		targetCharStyle[7][0] = myPrefArray[14];		targetCharStyle[7][1] = myPrefArray[15];		// 16, 17		targetCharStyle[8][0] = myPrefArray[16];		targetCharStyle[8][1] = myPrefArray[17];		// 18, 19		targetCharStyle[9][0] = myPrefArray[18];		targetCharStyle[9][1] = myPrefArray[19];		// 20		deliminator = myPrefArray[20];		// 21		deliminatorReplacement = myPrefArray[21];		// 22, 23		temp = "";		switch( myPrefArray[23] ) {			case "0":				temp = "";				break;			case "1" :				temp = "\t";				break;			case "2" :				temp = "\n";				break;			case "3" :				temp = "\r";				break;			//		}		tabReturnDelims[0][0] = myPrefArray[22];		tabReturnDelims[0][1] = temp;		// 24, 25		temp = "";		switch( myPrefArray[25] ) {			case "0":				temp = "";				break;			case "1" :				temp = "\t";				break;			case "2" :				temp = "\n";				break;			case "3" :				temp = "\r";				break;			//		}		tabReturnDelims[1][0] = myPrefArray[24];		tabReturnDelims[1][1] = temp;		// 26, 27		temp = "";		switch( myPrefArray[27] ) {			case "0":				temp = "";				break;			case "1" :				temp = "\t";				break;			case "2" :				temp = "\n";				break;			case "3" :				temp = "\r";				break;			//		}		tabReturnDelims[2][0] = myPrefArray[26];		tabReturnDelims[2][1] = temp;		// 28		if( myPrefArray[28] == "true" ) { 			addBackDelimOnFail = true;		} else {			addBackDelimOnFail = false;		}		////////////////////////////////////////////		// 29		if( myPrefArray[29] == "true" ) { 			reportResults = true;		} else {			reportResults = false;		}		////////////////////////////////////////////		// 30														// if replaceFontStyling is FALSE then we're just finding so we AUTO set select results = true 		if( myPrefArray[30] == "true" ) { 			selectResults = true;		} else {			selectResults = false;		}		// 31		if( myPrefArray[31] == "true" ) { 			selectResultsIfFailedOnly = true;		} else {			selectResultsIfFailedOnly = false;		}		// 32													// and clearSelectionStatus to true regardless of values given here but if TRUE then these settings will be respeted 		if( myPrefArray[32] == "true" ) { 			clearSelectionStatus = true;		} else {			clearSelectionStatus = false;		}		////////////////////////////						      			  // if BOTH are TRUE, then all objects in the document are processed, else if both False, just the ACTIVE SELECTION		// 33		if( myPrefArray[33] == "true" ) { 			examineSelectedOnly = true;		} else {			examineSelectedOnly = false;		}				return true;	} else {		return false;	}}function storePrefsActual( values ) {	myLoc.open("w");	myLoc.write(values);	myLoc.close();}function getServerLoc() {	//alert( "Got to getServerLoc" );	var yourName = "";	// Folder.myDocuments	myLoc = File(Folder.appData+"/stylizeBetweenPreferences.txt");	//	//if (myLoc.exists) {		//return (returnName());	//} else {		return (writeName( Folder.appData+"/stylizeBetweenPreferences.txt" ));	//}}function returnName() {	myLoc.open("r");	yourName = myLoc.readln();	myLoc.close();	return (yourName);}function writeName( fileLocation ) {	//alert( "got to writeName: " + fileLocation );	//var newName = prompt("Hi! I'm "+app.name+" "+app.version+". \n Where do you want your files saved?\nDon't worry, I'll only ask once...", "Directory Path here...", "Initialize Save Dir:");	//var verify = confirm("OK, I lied...\nAre you SURE you want to send files to THIS location?\n"+newName);		newName = fileLocation;		//if(newName.charAt(newName.length-1) != "\\" ){		//alert("appending slash");		//newName+="\\";	//}	//if(verify == true){		myLoc = File(newName);		//if(myLoc.exists){			myLoc.open("w");			myLoc.write(newName);			myLoc.close();		//} else{			//alert( "problems in paradise" );					   //return "Directory structure doesnt exist!!!";		//}	//} else{		//return "Nothing changed... Be more careful Next time...";	//}	return (newName);}function readPrefs( fileLocation ) {	//alert( "got to writeName: " + fileLocation );		newName = fileLocation;		myLoc = File(newName);	if(myLoc.exists){		myLoc.open("r");		prefsRaw = myLoc.read();		myLoc.close();		return prefsRaw;	} else{		alert( "there is no prefs file yet" );					return "Basic settings...";	}	return (newName);}// Don't let the beta go on for everfunction checkExpireDate() {	var Today = new Date();		// store parts of date into operatable form	var Day = Today.getDate();	var Month = Today.getMonth() + 1;	var Year = Today.getYear();		// make sure the year is right	if(Year < 999) Year += 2000;	if(Year > 2100) Year -= 100;		okayToRun = false;	// beta set to expire Jan. 15, 2010	if( Year == 2010 ) {		if( Month == 1 ) {			if( Day <= 15 ) { 				okayToRun = true;			}		}	} else if( Year <= 2009 ) {        okayToRun = true;     }		return okayToRun;};init();