// MakePointType// Nathaniel Vaughn KELSO// 2008.Feb.21 // at Hyattsville, MD// Version 0.3// DESC: Takes a area type box and extracts the text and turns into point type// DESC: Takes a type on path object and extracts the text and turns into point type//// TODO: Look inside groups// Version 0.3// (c) nvkelso [nathaniel(stop.at)kelsocartography.com]var rotateTypeThatWasPath = true;var rotatePointType = true;var rotatePointTypeInverse = false;var rotatePathTypeInverse = false;var convertPathType = false;var keepNonConvertedObjectedSelected = false;var keepNewPointTypeSelected = true;var lockNewPointType = false;var deleteOriginal = true;// Set how the text will be rotated depending on big- or little-endin math (supposition)// This seems to not make a difference nowif( File.fs == "Windows" ){	rotatePointTypeInverse = true;} else if( File.fs == "Macintosh" ){	if( Number( app.scriptingVersion ) <= 12 ) {		rotatePointTypeInverse = true;	} else {		rotatePointTypeInverse = true;	}} else {	alert("either Unix or Outerspace!!!");}if(documents.length > 0) {	doc = activeDocument;	mySelection = activeDocument.selection;	// If there are enough to process	if (mySelection instanceof Array) {		// For each of the selected items		var foundOne = false;		for(i=0; i<mySelection.length; i++) {			foundOne = false;						// That are textFrames			if (mySelection[i].typename == "TextFrame" && (mySelection[i].kind == TextType.AREATEXT || mySelection[i].kind == TextType.PATHTEXT ) ) {				obj = mySelection[i];								outlineObject = obj.duplicate();				outlineObject = outlineObject.createOutline();									objTop = outlineObject.top;				objLeft = outlineObject.left;				objMiddleX = outlineObject.left + .5 * outlineObject.width;				objMiddleY = outlineObject.top - .5 * outlineObject.height;				objRight = outlineObject.left + outlineObject.width;				objBottom = outlineObject.top - outlineObject.height;				objWidth = objRight - objLeft;				objHeight = objTop - objBottom;				opp = 0.0;				adj = 0.0				myAngle = 0.0;											// Make the new point type object and locate it				copy1 = obj.parent.textFrames.add();				// Make sure the new object is in the same Z stacking order as the original				copy1.move(obj, ElementPlacement.PLACEBEFORE);				// Run thru the lines				for(j=0;j<obj.lines.length;j++) {					frame = obj.lines[j];					// If there is more than one line add a char return					// TODO: Does this mess with formating to be Paragraph?					if(j>0) copy1.paragraphs.add("");					frame.duplicate(copy1);				}								if( obj.kind == TextType.AREATEXT ) {					foundOne = true;					if( obj.textPath.pathPoints.length == 4 ) {						// As long as the text is left justified						copy1.left = objLeft;						copy1.top = objTop;											if( rotatePointType ) {														// capture general angle for later							firstGeneralCharacter = outlineObject.pageItems.length - 1;							genX1 = outlineObject.pageItems[ firstGeneralCharacter ].left + 										 outlineObject.pageItems[ firstGeneralCharacter ].width / 2;							genY1 = outlineObject.pageItems[ firstGeneralCharacter ].top +										 outlineObject.pageItems[ firstGeneralCharacter ].height / 2;							genX2 = outlineObject.pageItems[ 0 ].left + 										 outlineObject.pageItems[ 0 ].width / 2;							genY2 = outlineObject.pageItems[ 0 ].top +										 outlineObject.pageItems[ 0 ].height / 2;							oppGen = -(genY2 - genY1);							adjGen = genX2 - genX1;							myAngleGen = Math.atan2(oppGen, adjGen);							myAngleGen = -1 * myAngleGen/Math.PI*180;																					if( rotatePointTypeInverse ) {								copy1.rotate(180);							}							pX = obj.textPath.pathPoints[0].anchor[0];							pY = obj.textPath.pathPoints[0].anchor[1];							qX = obj.textPath.pathPoints[1].anchor[0];							qY = obj.textPath.pathPoints[1].anchor[1];														// what if the boxes are Freehand style?							pX3 = obj.textPath.pathPoints[0].anchor[0];							pY3 = obj.textPath.pathPoints[0].anchor[1];							qX3 = obj.textPath.pathPoints[3].anchor[0];							qY3 = obj.textPath.pathPoints[3].anchor[1];							// NOTE: the angle returned depends on relationship of vectorInputs above!							opp = -(qY - pY);							adj = qX - pX;							myAngle = Math.atan2(opp, adj);							myAngle = -1 * myAngle/Math.PI*180;														opp3 = -(qY3 - pY3);							adj3 = qX3 - pX3;							myAngle3 = Math.atan2(opp3, adj3);							myAngle3 = -1 * myAngle3/Math.PI*180;														// test to see if Freehand style							if( opp > opp3 ) {								//myAngle = myAngle;								if( obj.textPath.polarity == PolarityValues.POSITIVE ) {									if( Math.abs( myAngleGen - myAngle ) < 175 ) {										myAngle = myAngle + 180;										//beep();									} else {										myAngle = myAngle;										//beep();									}								} else {									myAngle = myAngle;									//beep();								}							} else {								if( obj.textPath.polarity == PolarityValues.POSITIVE ) {									if( Math.abs( myAngleGen - myAngle ) < 175 ) {										myAngle = myAngle3 + 270;										//beep();									} else {										myAngle = myAngle3 + 90;										//beep();									}								} else {									myAngle = myAngle3;									//beep();								}							}														//alert( "general: " + myAngleGen + " and specific: " + myAngle );														copy1.rotate( myAngle );							copy1.left = objLeft;							copy1.top = objTop;						}					}					} else if( obj.kind == TextType.PATHTEXT && convertPathType) {					foundOne = true;										// keep track of the original justification... seems to work better if left justified for transforms???					oldRegistration = obj.story.textRange.justification;					copy1.story.textRange.justification = Justification.FULLJUSTIFYLASTLINELEFT;										/* // GENERAL FORM FOR TOTAL LINE					// endPointElement = obj.textPath.pathPoints.length - 1;											pX = obj.textPath.pathPoints[0].anchor[0];					pY = obj.textPath.pathPoints[0].anchor[1];					qX = obj.textPath.pathPoints[endPointElement].anchor[0];					qY = obj.textPath.pathPoints[endPointElement].anchor[1];					*/									// SPECIFIC FORM FOR START AND STOP OF TEXT					startCharacterElement = outlineObject.pageItems.length - 1;					// This solves badly the case where period punctuation at the end gives back bad angle measures					// TODO: Should really test for the last char onthe line and if "." then set to 1, else 0.					lastCharElement = 1;										pX = outlineObject.pageItems[ startCharacterElement ].position[0] +							outlineObject.pageItems[ startCharacterElement ].width / 2;					pY = outlineObject.pageItems[ startCharacterElement ].position[1] + 							outlineObject.pageItems[ startCharacterElement ].height / 2;					qX = outlineObject.pageItems[ lastCharElement ].position[0] +							outlineObject.pageItems[ lastCharElement ].width / 2;					qY = outlineObject.pageItems[ lastCharElement ].position[1] +							outlineObject.pageItems[ lastCharElement ].height / 2;										// NOTE: the angle returned depends on relationship of vectorInputs!					opp = -(qY - pY);					adj = qX - pX;					myAngle = Math.atan2(opp, adj);					myAngle = -1 * myAngle/Math.PI*180;											// KNOW THIS...					// degrees in Ai measured up from intersection of 0 and 4 quadrants so light going from 0,0 to right					// if point is abov ethat line, then positive. So 90° is straight up, -90° is straight down from 0,0.					if( rotateTypeThatWasPath ) {						copy1.rotate( myAngle );						if( rotatePathTypeInverse ) {							copy1.rotate(180);						}						copy1.story.textRange.justification = oldRegistration;						// force it to be where it was, again						copy1.left = objLeft;						copy1.top = objTop;					} else {						// force it to be where it was, again						// Default state for left justification						copy1.left = objLeft;						copy1.top = objMiddleY;								// state for center justification						if( oldRegistration ==  Justification.CENTER ) {							copy1.left = objMiddleX;							copy1.top = objMiddleY;						}						// state for right justification						if( oldRegistration ==  Justification.RIGHT ) {							copy1.left = objRight;							copy1.top = objMiddleY;						}						copy1.story.textRange.justification = oldRegistration;					}				} 								differenceCompareObject = copy1.duplicate();				differenceCompareObject = differenceCompareObject.createOutline();									startCharacterElementOrig = outlineObject.pageItems.length - 1;				startCharacterElementNew = differenceCompareObject.pageItems.length - 1;				differenceLeft = outlineObject.pageItems[startCharacterElementOrig].position[0] - differenceCompareObject.pageItems[startCharacterElementNew].position[0];				differenceTop = outlineObject.pageItems[startCharacterElementOrig].position[1] - differenceCompareObject.pageItems[startCharacterElementNew].position[1];								copy1.top = copy1.top + differenceTop;				copy1.left = copy1.left + differenceLeft;								// Always delete these intermediate objects				outlineObject.remove();				differenceCompareObject.remove();								// Now keep the new one selected				if( keepNewPointTypeSelected ) {					copy1.selected = true;				} else {					copy1.selected = false;				}								if( lockNewPointType ) {					copy1.locked = true;				} else {					copy1.locked = false;				}							if( convertPathType == false && (mySelection[i].kind == TextType.PATHTEXT) ) {					copy1.remove();				}							if( deleteOriginal && foundOne )  {					// DELETE ENTIRE ORIG OBJECT					mySelection[i].remove();				}			}			if( keepNonConvertedObjectedSelected ) {				try {					mySelection[i].selected = true;			// redundant since already was true				} catch (theError) {}			} else {				try { 					mySelection[i].selected = false;				} catch (theError) {}			}					}	}}