// Framer// Nathaniel Vaughn KELSO// 2007.July.8 // at Hyattsville, MD// Version 0.3// TODO: Fix baseline offset issue (where the text frame moves up from where the point text was)// Version 0.2// (c) vd [vd(kot)online.com.ua]var keepNonConvertedObjectedSelected = false;var keepNewAreaTypeSelected = true;var deleteOriginal = true;var rotateAreaTeype= true;var rotateAreaTypeInverse = true;var straightTextAngleThreshold = 10;if(documents.length > 0) {	doc = activeDocument;	mySelection = activeDocument.selection;	if (mySelection instanceof Array) {		var foundOne = false;		for(i=0; i<mySelection.length; i++) {			foundOne = false;			if (mySelection[i].typename == "TextFrame" && mySelection[i].kind == TextType.POINTTEXT) {				foundOne = true;				obj = mySelection[i];								// keep track of the original justification... seems to work better if left justified for transforms???				//oldRegistration = obj.story.textRange.justification;								// Make the new point type object and locate it				horizontalTypeMeasure = obj.parent.textFrames.add();				// Make sure the new object is in the same Z stacking order as the original				horizontalTypeMeasure.move(obj, ElementPlacement.PLACEAFTER);								// keep track of original characters				//outlineObject = obj.duplicate();				//outlineObject = outlineObject.createOutline();				// Run thru the lines				for(j=0;j<obj.lines.length;j++) {					frame = obj.lines[j];					// If there is more than one line add a char return					// TODO: Does this mess with formating to be Paragraph?					if(j>0) horizontalTypeMeasure.paragraphs.add("");					frame.duplicate(horizontalTypeMeasure);				}							/* // SPECIFIC FORM FOR START AND STOP OF TEXT				startCharacterElement = outlineObject.pageItems.length - 1;				pX = outlineObject.pageItems[startCharacterElement].position[0];				pY = outlineObject.pageItems[startCharacterElement].position[1];				qX = outlineObject.pageItems[0].position[0];				qY = outlineObject.pageItems[0].position[1];				*/								// SPECIFIC FORM FOR START AND STOP OF TEXT				objTop = horizontalTypeMeasure.top;				objLeft = horizontalTypeMeasure.left;				objRight = horizontalTypeMeasure.left + horizontalTypeMeasure.width;				objBottom = horizontalTypeMeasure.top - horizontalTypeMeasure.height;				objWidth = horizontalTypeMeasure.width;				objHeight = horizontalTypeMeasure.height;								origLeft = obj.left;				origTop = obj.top;												// start calculating the orientation of the point text				pX = obj.left;				pY = obj.top;				qX = obj.left + obj.width;				qY = obj.top - obj.height;												// NOTE: the angle returned depends on relationship of vectorInputs!				opp = -(qY - pY);				adj = qX - pX;				theSign = opp / adj;				myAngle = Math.atan2(opp, adj);				myAngle = -1 * myAngle/Math.PI*180;								//anchor x,y				//position x,y				//function isHiOrLeft(a,b){				//	if(a.position[1]-a.height > b.position[1]-b.height){				//		a.name = "hi";				//		return true;				//	} else if (a.position[1]-a.height == b.position[1]-b.height && a.position[0] < b.position[0]) {				//		a.name = "left";				//		return true;				//	}				//	return false;				//}							// TODO: Fix baseline offset issue				// (where the text frame moves up from where the point text was)				if( myAngle < (-1 * straightTextAngleThreshold) ) {					objWidth *= -1;					objHeight *= -1;					}				rect = doc.pathItems.rectangle(origTop,origLeft,objWidth,objHeight);				copy1 = doc.textFrames.areaText(rect);				// Make sure the new object is in the same Z stacking order as the original				copy1.move(obj, ElementPlacement.PLACEAFTER);				obj.textRange.duplicate(copy1);								// This was in the other one, might not be necc.				//copy1.story.textRange.justification = Justification.FULLJUSTIFYLASTLINELEFT;								if( rotateAreaTypeInverse ) {					prompt(myAngle,theSign);					if( myAngle > 180 )  {						copy1.rotate(180);					} else {						copy1.rotate(-180);					}				}					if( rotateAreaTeype ) {					if( (myAngle > straightTextAngleThreshold) || (myAngle < (-1*straightTextAngleThreshold)) ) {						copy1.rotate( myAngle );					}					copy1.left = origLeft;					copy1.top = origTop;				}				// Now keep the new one selected				if( keepNewAreaTypeSelected ) {					rect.selected = true;					copy1.selected = true;					//theCopy1TextRange.select(true);				} else {					rect.selected = false;					//copy1.textRange.deselect();				}							if( deleteOriginal && foundOne )  {					// DELETE ENTIRE ORIG OBJECT					mySelection[i].remove();				}				// should always clean up the measurement object				horizontalTypeMeasure.remove();				// Always delete this intermediate object				//outlineObject.remove();								// and return the justification				//copy1.story.textRange.justification = oldRegistration;			}			if( keepNonConvertedObjectedSelected ) {				try {					mySelection[i].selected = true;			// redundant since already was true				} catch (theError) {}			} else {				try { 					mySelection[i].selected = false;				} catch (theError) {}			}					}	}}