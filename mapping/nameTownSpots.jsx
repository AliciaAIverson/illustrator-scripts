var mainSel = [];var whereBase = [];var typeObjs = [];var pathObjs = [];var groupObjs = [];var symbolObjs = [];var typeObjsMatched = [];var pathObjsMatched = [];var pathObjsMatchedDup = [];var groupObjsMatched = [];var symbolObjsMatched = [];var badNames = [];	badNames.push( "[MAPublisher Default Symbol]" );	  //badNames.push( "INSERT", "BLOCK_RECORD", "HATCH", "<PATH>" );var variableSearchRadius = false;var fromCenter = false;var scaleFactorOnVariableSearchRadiusX = 2.0;var scaleFactorOnVariableSearchRadiusY = 2.0;var setSearchRadiusX = 2.5; 		// in page units (points)var setSearchRadiusY = 2.5; 		// in page units (points)var searchRadiusX = 1;var searchRadiusY = 1;var searchBounds = [];		// xmin, xmax, ymin, ymaxvar checkBothLeftAndRightTextFrameLoc = true;var preventDupNames;var keepNullMatchesSelected = true;var keepDupMatchesSelected = true;var whereMethod = "document";  	// "activeTopLevelLayer", "document", var selectionOnly = true;var includeLocked = false;var reviewObjX = 0;var reviewObjY = 0;var startTime = new Date();main();function main() {	switch( whereMethod ) {		case "activeLayer":			whereBase = app.activeDocument.activeLayer;			break;		case "activeTopLevelLayer":			if( app.activeDocument.activeLayer.parent.typename == "Document" ) {				whereBase = app.activeDocument.activeLayer;			} else if( app.activeDocument.activeLayer.parent.typename == "Layer" ) {				if( app.activeDocument.activeLayer.parent.parent.typename == "Document" ) {					whereBase = app.activeDocument.activeLayer.parent;				} else if( app.activeDocument.activeLayer.parent.parent.parent.typename == "Document" ) {					whereBase = app.activeDocument.activeLayer.parent.parent;				} else {					whereBase = app.activeDocument.activeLayer.parent.parent;				}			}			break;		case "document" :		default :			whereBase = app.activeDocument;			break;	}	mainSel = whereBase.pageItems;	//alert( "mainSel: " + mainSel + " whereBase: " + whereBase );	if( mainSel != undefined ) {		for( i=0; i<mainSel.length; i++ ) {			if( includeLocked == false ) {				if( mainSel[i].locked ) {					continue;				}			}						if( selectionOnly ) {				if( mainSel[i].selected == false ) {					continue;				}			}			switch( mainSel[i].typename ) {				case 'TextFrame':					typeObjs.push( mainSel[i] );					break;				case 'PathItem':					pathObjs.push( mainSel[i] );					break;				case 'GroupItem':					switch( mainSel[i].pageItems.length ) {						case 2:							if( mainSel[i].pathItems.length == 1 && mainSel[i].textFrames.length == 1 ) {								groupObjs.push( mainSel[i] );							}  else {								if( mainSel[i].pathItems.length ==1 && mainSel[i].groupItems.length == 1 ) {									if( mainSel[i].groupItems[0].typename == "TextFrame" ) {										groupObjs.push( mainSel[i] );									} else {										pathObjs.push( mainSel[i] );									} 								} else {									pathObjs.push( mainSel[i] );									}							}							break;						case 1:							if( mainSel[i].textFrames.length == 1 ) {								typeObjs.push( mainSel[i] );							} else {								pathObjs.push( mainSel[i] );							}						default :							pathObjs.push( mainSel[i] );							break;					}					break;				case 'SymbolItem':					// We can treat them as the same as pathObjs as they have the same width, height, top, left properties					pathObjs.push( mainSel[i] );					//symbolObjs.push( mainSel[i] );					break;				default :					continue;			}		}	} else {		alert( "Make sure there are objects in your document and, if you specified a selection, that some are selected." );		//return;	}		/*	if( typeObjs.length != (pathObjs.length + symbolObjs.length) ) {		if( typeObjs.length < (pathObjs.length + symbolObjs.length) ) {			alert( "There were less text labels than points. You might have some unlabled path items." );		} else {			alert( "There were more text labels than points. You might have multiple labels on your path items." );		}	}	*/	//alert( "typeObjs: " + typeObjs.length + " pathObjs: " + pathObjs.length + " groupObjs: " + groupObjs.length + " symbolObjs: " + symbolObjs.length );	for( j=0; j<typeObjs.length; j++ ) {		typeObjsMatched[ j ] = false;	}	for( j=0; j<pathObjs.length; j++ ) {		pathObjsMatched[ j ] = false;		pathObjsMatchedDup[ j ] = false;	}	for( j=0; j<groupObjs.length; j++ ) {		groupObjsMatched[ j ] = false;	}	for( j=0; j<symbolObjs.length; j++ ) {		symbolObjsMatched[ j ] = false;	}	if( pathObjs != undefined ) {		// For the loose path and text items		for( i=0; i<pathObjs.length; i++ ) {			if( variableSearchRadius ) {				searchRadiusX = scaleFactorOnVariableSearchRadiusX * pathObjs[i].width / 2;				searchRadiusY = scaleFactorOnVariableSearchRadiusY * pathObjs[i].height / 2;				//var searchBounds = [];		// xmin, xmax, ymin, ymax				if( fromCenter ) {					searchBounds = [ pathObjs[i].left + pathObjs[i].width / 2 - searchRadiusX, pathObjs[i].left + pathObjs[i].width / 2 + searchRadiusX , pathObjs[i].top + pathObjs[i].height / 2 - searchRadiusY, pathObjs[i].top - pathObjs[i].height / 2+ searchRadiusY ]				} else {					searchBounds = [ pathObjs[i].left - searchRadiusX, pathObjs[i].left + pathObjs[i].width + searchRadiusX , pathObjs[i].top - pathObjs[i].height - searchRadiusY, pathObjs[i].top + searchRadiusY ]				}			} else {				if( fromCenter ) {					searchBounds = [ pathObjs[i].left + pathObjs[i].width / 2 - setSearchRadiusX, pathObjs[i].left + pathObjs[i].width / 2 + setSearchRadiusX , pathObjs[i].top + pathObjs[i].height / 2 - setSearchRadiusY, pathObjs[i].top - pathObjs[i].height / 2+ setSearchRadiusY ]				} else {					searchBounds = [ pathObjs[i].left - setSearchRadiusX, pathObjs[i].left + pathObjs[i].width + setSearchRadiusX , pathObjs[i].top - pathObjs[i].height - setSearchRadiusY, pathObjs[i].top + setSearchRadiusY ]				}			}						//alert( searchBounds );						//var matchesLoc = false;			var matchingTextFields = [];			var typeObjX = 0;			var typeObjY = 0;					for( j=0; j<typeObjs.length; j++ ) {				//matchesLoc = false;				multipleResults = [];								// test to see if the textItem is nearby				if( typeObjs[j].kind == TextType.POINTTEXT ) {					switch( typeObjs[j].paragraphs[0].justification ) {						case Justification.RIGHT :						case Justification.FULLJUSTIFYLASTLINERIGHT :							typeObjX = typeObjs[j].anchor[0] + typeObjs[j].width;							typeObjY = typeObjs[j].anchor[1];							break;						case Justification.CENTER :							typeObjX = typeObjs[j].anchor[0] + typeObjs[j].width / 2;							typeObjY = typeObjs[j].anchor[1];							break;						case Justification.LEFT :						case Justification.FULLJUSTIFY :						case Justification.FULLJUSTIFYLASTLINELEFT :						case Justification.FULLJUSTIFYLASTLINERIGHT :						case Justification.FULLJUSTIFYLASTLINECENTER :						default :							typeObjX = typeObjs[j].anchor[0];							typeObjY = typeObjs[j].anchor[1];							break;						//					}										if( typeObjX >= searchBounds[0] && typeObjX <= searchBounds[1] &&						typeObjY >= searchBounds[2] && typeObjY <= searchBounds[3]					) {						matchingTextFields.push( j );						typeObjsMatched[ j ] = true;					}				}			}						// Only look for opposite side of text frame if didn't find something in the first place			if( matchingTextFields.length == 0 && checkBothLeftAndRightTextFrameLoc ) {				for( j=0; j<typeObjs.length; j++ ) {					// test to see if the textItem is nearby					if( typeObjs[j].kind == TextType.POINTTEXT ) {						switch( typeObjs[j].paragraphs[0].justification ) {							case Justification.RIGHT :							case Justification.FULLJUSTIFYLASTLINERIGHT :								typeObjX = typeObjs[j].anchor[0];								typeObjY = typeObjs[j].anchor[1];								break;							case Justification.CENTER :								typeObjX = typeObjs[j].anchor[0] + typeObjs[j].width / 2;								typeObjY = typeObjs[j].anchor[1];								break;							case Justification.LEFT :							case Justification.FULLJUSTIFY :							case Justification.FULLJUSTIFYLASTLINELEFT :							case Justification.FULLJUSTIFYLASTLINERIGHT :							case Justification.FULLJUSTIFYLASTLINECENTER :							default :								typeObjX = typeObjs[j].anchor[0] + typeObjs[j].width;								typeObjY = typeObjs[j].anchor[1];								break;							//						}											if( typeObjX >= searchBounds[0] && typeObjX <= searchBounds[1] &&							typeObjY >= searchBounds[2] && typeObjY <= searchBounds[3]						) {								matchingTextFields.push( j );								typeObjsMatched[ j ] = true;						}					}				}							// sort by distance in XY hypotenous				reviewObjX = pathObjs[i].left + pathObjs[i].width / 2;				reviewObjY = pathObjs[i].top- pathObjs[i].height / 2;				if( matchingTextFields.length > 1 ) {					matchingTextFields.sort( sortByDistanceAwayOpposite );				}			} else {				// sort by distance in XY hypotenous				reviewObjX = pathObjs[i].left + pathObjs[i].width / 2;				reviewObjY = pathObjs[i].top- pathObjs[i].height / 2;				if( matchingTextFields.length > 1 ) {					matchingTextFields.sort( sortByDistanceAway );				}			}								if( matchingTextFields.length >= 1 ) {				// If it's nearby, apply the text content onto the pathItem's name (visible in the Layers  object list)				// if this is the 2nd name it is receiving, deliminate with | pipe symbol				for( a=0; a<badNames.length; a++ ) {					if( pathObjs[i].name == badNames[a] ) {						pathObjs[i].name = "";					}				}								var tempDelim = "";				pathObjs[i].name = "";												for( j=0; j<matchingTextFields.length; j++ ) {					//if( pathObjs[i].name.length > 0 ) {						//if( preventDupNames ) {							//if( pathObjs[i].name != typeObjs[ matchingTextFields[j] ].contents ) {								pathObjs[i].name += tempDelim + typeObjs[  matchingTextFields[j]  ].contents;								//pathObjsMatchedDup[ i ] = true;							//}						//} else {							//pathObjs[i].name += "|" + typeObjs[  matchingTextFields[j] ].contents;						//}					//} else {						//pathObjs[i].name = typeObjs[  matchingTextFields[j]  ].contents;					//}					tempDelim = "|";				}								pathObjsMatched[ i ] = true;				if( matchingTextFields.length > 1 ) {					pathObjsMatchedDup[ i ] = true;				}			}		}				//alert( "groupObjs: " +  groupObjs.length );		// For the grouped path and text items 		for( i=0; i<groupObjs.length; i++ ) {			groupObjs[i].pathItems[0].name = groupObjs[i].textFrames[0].contents; 			groupObjsMatched[ i ] = true;		}	}	if( keepNullMatchesSelected ) {		for( j=0; j<typeObjs.length; j++ ) {			if( typeObjsMatched[ j ] ) {				typeObjs[j].selected = false;			} else {				typeObjs[j].selected = true;			}		}		for( j=0; j<pathObjs.length; j++ ) {			if( pathObjsMatched[ j ] ) {				pathObjs[j].selected = false;			} else {				pathObjs[j].selected = true;			}		}		for( j=0; j<groupObjs.length; j++ ) {			if( groupObjsMatched[ j ] ) {				groupObjs[j].selected = false;			} else {				groupObjs[j].selected = true;			}		}	}	if( keepDupMatchesSelected ) {		for( j=0; j<pathObjs.length; j++ ) {			if( pathObjsMatchedDup[ j ] ) {				pathObjs[j].selected = true;			}		}	}		var totalTime = (new Date() - startTime) / 1000 / 60;	alert( "Time elapsed: " + totalTime + " minute(s)" );}//anchor x,y//position x,yfunction sortByDistanceAway(x,y){	var a = typeObjs[  x  ];	var b = typeObjs[  y  ];	var typeObjAx = 0;	var typeObjAy = 0;	var typeObjBx = 0;	var typeObjBy = 0;		//if( typeObjs[j].kind == TextType.POINTTEXT ) {		switch( a.paragraphs[0].justification ) {			case Justification.RIGHT :			case Justification.FULLJUSTIFYLASTLINERIGHT :				typeObjAx = a.anchor[0] + a.width;				typeObjAy = a.anchor[1] + a.height;				break;			case Justification.CENTER :				typeObjAx = a.anchor[0] + a.width / 2;				typeObjAy = a.anchor[1] + a.height / 2;				break;			case Justification.LEFT :			case Justification.FULLJUSTIFY :			case Justification.FULLJUSTIFYLASTLINELEFT :			case Justification.FULLJUSTIFYLASTLINERIGHT :			case Justification.FULLJUSTIFYLASTLINECENTER :			default :				typeObjAx = a.anchor[0];				typeObjAy = a.anchor[1];				break;			//		}				switch( b.paragraphs[0].justification ) {			case Justification.RIGHT :			case Justification.FULLJUSTIFYLASTLINERIGHT :				typeObjBx = b.anchor[0] + b.width;				typeObjBy = b.anchor[1] + b.height;				break;			case Justification.CENTER :				typeObjBx = b.anchor[0] + b.width / 2;				typeObjBy = b.anchor[1] + b.height / 2;				break;			case Justification.LEFT :			case Justification.FULLJUSTIFY :			case Justification.FULLJUSTIFYLASTLINELEFT :			case Justification.FULLJUSTIFYLASTLINERIGHT :			case Justification.FULLJUSTIFYLASTLINECENTER :			default :				typeObjBx = b.anchor[0];				typeObjBy = b.anchor[1];				break;			//		}		var deltaA = Math.pow( Math.pow( reviewObjX - typeObjAx, 2 ) + Math.pow( reviewObjY - typeObjAy, 2 ), 0.5 );	var deltaB = Math.pow( Math.pow( reviewObjX - typeObjBx, 2 ) + Math.pow( reviewObjY - typeObjBy, 2 ), 0.5) ;			if( deltaA > deltaB) {		//alert( a.contents + " is less than " + b.contents + " by: " + deltaA + " and " + deltaB );		// now test for opposite side		return true;	} else {		 return false;	}}function sortByDistanceAwayOpposite(x,y){	var a = typeObjs[  x  ];	var b = typeObjs[  y  ];	var typeObjAx_opp = 0;	var typeObjAy_opp = 0;	var typeObjBx_opp = 0;	var typeObjBy_opp = 0;		//if( typeObjs[j].kind == TextType.POINTTEXT ) {		switch( a.paragraphs[0].justification ) {			case Justification.RIGHT :			case Justification.FULLJUSTIFYLASTLINERIGHT :				typeObjAx_opp = a.anchor[0];				typeObjAy_opp = a.anchor[1];				break;			case Justification.CENTER :				typeObjAx_opp = typeObjAx;				typeObjAy_opp = typeObjBy;				break;			case Justification.LEFT :			case Justification.FULLJUSTIFY :			case Justification.FULLJUSTIFYLASTLINELEFT :			case Justification.FULLJUSTIFYLASTLINERIGHT :			case Justification.FULLJUSTIFYLASTLINECENTER :			default :				typeObjAx_opp = a.anchor[0] + a.width;				typeObjAy_opp = a.anchor[1] + a.height;				break;			//		}				switch( b.paragraphs[0].justification ) {			case Justification.RIGHT :			case Justification.FULLJUSTIFYLASTLINERIGHT :				typeObjBx_opp = b.anchor[0];				typeObjBy_opp = b.anchor[1];				break;			case Justification.CENTER :				typeObjBx_opp = typeObjBx;				typeObjBy_opp = typeObjBy;				break;			case Justification.LEFT :			case Justification.FULLJUSTIFY :			case Justification.FULLJUSTIFYLASTLINELEFT :			case Justification.FULLJUSTIFYLASTLINERIGHT :			case Justification.FULLJUSTIFYLASTLINECENTER :			default :				typeObjBx_opp = b.anchor[0] + b.width;				typeObjBy_opp = b.anchor[1] + b.height;				break;			//		}			var deltaA_opp = Math.pow( Math.pow( reviewObjX - typeObjAx_opp, 2 ) + Math.pow( reviewObjY - typeObjAy_opp, 2 ), 0.5 );	var deltaB_opp = Math.pow( Math.pow( reviewObjX - typeObjBx_opp, 2 ) + Math.pow( reviewObjY - typeObjBy_opp, 2 ), 0.5) ;	if( deltaA_opp > deltaB_opp ) {		return true;	} else {		return false;	}}