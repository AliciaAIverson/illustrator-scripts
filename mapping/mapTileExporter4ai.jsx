/* Map Tile Exporter for Adobe Illustrator     Nathaniel Vaughn Kelso, only tested in CS3      Modified from Photoshop version, original credit to:   Will James - http://onNYTurf.com   Nate Bundy - http://www.lemonrage.com/*/// Setup our doc variablesvar doc = app.activeDocument;var f_ext = "gif";var dest="C:\\Temp";				// Obviously not C:\ if you're on a Mac, calculated latervar maxAllowedZoom = 22;var tileSetPathSeparator = "_";	// Use of a / to indicate subdirectories is not supported at this time.// set each file type to true that you wish the script to save out. you may save out all three at the same time if you wishvar saveJPEG = false;var savePNG = true;var saveGIF = false;var saveSVG = false;//**** YOU SHOULD CUSTOMIZE THE FOLLOWING VARIABLE DEPENDING ON YOUR NEED ****var highestZoomLevel = -1; // Enter the highest zoom level we are creating tiles for (should be less than OrgZoom; technically the  script should be able to handle values larger as well, but your image quality will suffer)var lowestZoomLevel = -1; // Enter the last zoom level we want to create tiles for (must be <= HighestZoomLevel for the script to do anything)// We start with the coordinates, zoom, and width of an upper left corner tile and generate everything from there// We can calculate new tile values from these values for any zoom level without having to look up these details for each.var orgX = -1;   // 31551 the Google Maps X value of the tile at the top left corner of your Photoshop documentvar orgY = -1;   // 50899 the Google Maps Y value of the tile at the top left corner of your Photoshop documentvar orgZoomLevel = -1;   // the Google Maps zoom level of your Photoshop document (for best results, you will need to resize your  Photoshop document to match a zoom level as closely as possible before running this script)var zoomLevel = -1;var lastZoomLevel = -1;	var currentX = -1;var currentY = -1;	  var bnd = new Array();var cropOLD;// For maps built at screen size of 1 tile grid = 256 page units, set to 1.0// For maps built at print size of 1 tile grid = less than 256 page units, set to value like 1.725// NOTE: Maps from Arc built at scale need to be scaled down by .57971 to work at Print font sizes// Chaning this number can affect a whole host of other formula. Danger, Will Robinson!var print2webScaler = new Number;	  //print2webScaler = 1.0;	  print2webScaler = 1.725;			      // Keep things abstractvar exportScaler = 1.0;// Snap to whole pixelsvar scalerSubPixelThresholdX = .4;var scalerSubPixelThresholdY = .4;// Pixles per inch// Works well for 72 (1x), 144 (2x for high res mobile phones and the like), and 216 (3x for the future) ppi. // Other settings may produce odd results.// NOTE: Only applie to raster formats (not EPS or SVG export).var targetPPI = 72;			var referencePPI = 72;var targetPixelMeasure = 256;// Your width and height should be 256 unless you override Google's default in a custom map typevar pixelWidth = 256; var pixelHeight = 256;// Used to guess the zoom level so the user doesn't have to think as muchvar contentWidth = 0;	var contentHeight = 0;// Setup the scale factor:pixelWidth /= print2webScaler;pixelHeight /= print2webScaler;var timeStart = new Date();var timeEnd = new Date();var tilesMiled = 0;// Determine the content area, set crop to content// setCropArea();function init() {	timeStart = new Date();		// TODO: Revise to accomodate CS4, CS5, CS6 artboard cooption of crop areas API	// Remember the existing crop settings so we can return to them	try{		if( doc.cropBox[0] == null || doc.cropBox[0] >= 10000 ) {			theNullBox = new Array( 16383, 16383, 16383, 16383 );			cropOLD = theNullBox;			// Determine the content area, set crop to content			setCropArea();		} else {			cropOLD = doc.cropBox;			bnd[0] =  doc.cropBox[0];			bnd[2] =  doc.cropBox[2];			bnd[1] =  doc.cropBox[1];			bnd[3] =  doc.cropBox[3];		}	} catch (e) {		theNullBox = new Array( 16383, 16383, 16383, 16383 );		doc.cropBox = theNullBox;		var cropOLD = doc.cropBox;			// Determine the content area, set crop to content		setCropArea();	}		// If the tile location can be determined, make the tiles	if( getZoomLevel() ) {		makeTiles();	}	timeEnd = new Date();	var timeTotal = (timeStart - timeEnd ) / 1000;		alert( tilesMiled + " tiles were cut in " + timeTotal + " seconds" );		// reset the crop box to whatever it was before	doc.cropBox = cropOLD;}function getZoomLevel() {	var tempZoom = null;	var tempOrgX = null;	var tempOrgY = null;	var worldMap = false;	var addBuffer = false;	var adjustScaler = false;	var addWidth = 0;	var addHeight = 0;	var note = "";		// Determine the content / crop width and overages or underages	contentWidth = bnd[2] - bnd[0];	contentHeight = bnd[1] - bnd[3];		//contentWidth /= print2webScaler;	//contentHeight /= print2webScaler;	//scalerSubPixelThresholdX /= print2webScaler;		var content256ratio = contentWidth / targetPixelMeasure;	// Calculate this hear instead of repeatidly in the export (saveAs) functions	exportScaler = Math.ceil( print2webScaler * 100 * targetPPI / referencePPI );	// We're 1 pixel off when print2webScaler is not 1.0	// Fuzzy to add a 1 to it and it somehow works, magic. Seems to be a bad math engine somewhere else :\	if( targetPPI != referencePPI) {		exportScaler = exportScaler + 1;	}			addWidth  = pixelWidth - (contentWidth % pixelWidth);	addHeight = pixelHeight - (contentHeight % pixelHeight);		//alert( "addWidth: " + addWidth + " and addHeight: " + addHeight );		if( addWidth == pixelWidth ||  addWidth < scalerSubPixelThresholdX * print2webScaler ) {		addWidth = 0;	}	if( addHeight == pixelHeight ||  addHeight < scalerSubPixelThresholdY * print2webScaler  ) {		addHeight = 0;	}	// Ask if we should adjust the crop on the content	if( addWidth > 0 || addHeight > 0 ) {				if( print2webScaler != 1 ) {	    		note = "\nNOTE: You're not using a standard resolution so the normal 256 pixel grid has been adjusted.";	    }	 			addBuffer = confirm( "Your grid is off by " + addWidth +" width and " + addHeight + " height. Try adjusting your content to fit the " + pixelWidth + " px grid." + note + "\n\nDo you want to proceed anyways?" );	    	    if( addBuffer ) {	 		adjustScaler = confirm( "Stretch your content to fit? If no, your crop will be adjusted to the next larger tile edge." );	 		 		if( adjustScaler ) {	 			print2webScaler = contentWidth / targetPixelMeasure / Math.round( contentWidth / targetPixelMeasure );	 		} else {	 		 	addBuffer = confirm( "Extend the crop to next " + pixelWidth + " px tile edge?" + note + " \n\nPressing no will reduce the crop instead." );				if( 	addBuffer ) {					// Extend crop to next 256 interval								// prompt( bnd[0], bnd[1], bnd[2] );					//W = bnd[2] - bnd[0];					//H = bnd[1] - bnd[3];					//X = bnd[0];					//Y = bnd[1];						// increase the width from uppler left					bnd[2] = bnd[0] + Math.ceil( (contentWidth * print2webScaler) / (pixelWidth * print2webScaler) ) * (pixelWidth * print2webScaler);					// increase the height from uppler left					bnd[3] = bnd[1] - Math.ceil( (contentHeight * print2webScaler) / (contentHeight * print2webScaler) ) * (contentHeight * print2webScaler);				} else {					// decrease the width from uppler left					bnd[2] = bnd[0] + Math.floor( (contentWidth * print2webScaler) / (pixelWidth * print2webScaler) ) * (pixelWidth * print2webScaler);					// decrease the height from uppler left					bnd[3] = bnd[1] - Math.floor( (contentHeight * print2webScaler) / (contentHeight * print2webScaler) ) * (contentHeight * print2webScaler);				}					// prompt( bnd[0], bnd[1], bnd[2] );				doc.cropBox = bnd;				//doc.cropStyle = CropOptions.Standard;		 		}		} else {			return false;		}					}			tempZoom= Math.log( (contentWidth * print2webScaler) / (pixelWidth * print2webScaler)) / Math.log(2);		if( tempZoom % 1 == 0 ) {		worldMap = confirm( "Is this a map of the entire world?\nAssumes 0,0 top-left tile, full width content, zooms 0 to 6." );	}		if( worldMap ) {		// 256*2^zoom		// http://stackoverflow.com/questions/3286438/ruby-whats-the-reverse-of-math-power		tempZoom = Math.round( tempZoom );		tempOrgX = 0;   // the Google Maps X value of the tile at the top left corner of your Illustrator document		tempOrgY = 0;	// the Google Maps Yvalue of the tile at the top left corner of your Illustrator document	} else {		guessSettings = confirm( "Guess settings based on file name?\nExample: myfilename_z#_x#_y#.ai" );				if( guessSettings ) {				// Capture the full file name (but not the path)			var theDocName = activeDocument.name;			// The 8x3 extention preceeded by "." as in ".ai" is not required on the Mac, we don't want that part of the name			var theFileExtIndex = theDocName.lastIndexOf(".")						if( theFileExtIndex < 0 ) { 				theFileExtIndex = theDocName.length - 1;			}			// Strip out the file extention			theDocName = theDocName.substr( 0, theFileExtIndex );			// We're interested in filenames with the following keywords: _z#_x#_y#			var theDocNameParams = theDocName.split( "_" );			var tempDict;			//alert( theDocName );						for( var q = 0; q< theDocNameParams.length; q++) {				tempDict = theDocNameParams[q].split( "-" );								if( tempDict[0] == "z" ) {					tempZoom= tempDict[1];				}				if( tempDict[0] == "x" ) {					tempOrgX = tempDict[1];				}				if( tempDict[0] == "y" ) {					tempOrgY = tempDict[1];				}			}		} else {			prompt( "Need help figuring out your settings?\nHere's a helpful web resource:", "http://www.maptiler.org/google-maps-coordinates-tile-bounds-projection/" );			return false;		}	}			// If guess settings failed, or we just wanted to ask the user to begin with	if( tempZoom == null || tempOrgX == null || tempOrgY == null ) {		tempZoom = prompt( "What zoom level are you targeting?\nZooms 0 thru 22 are acceptable.", "" )					tempOrgX = prompt( "What is the top-left tile position X?", "" );					tempOrgY = prompt( "What is the top-left tile position Y?", "" );				}	//alert( "Using the following settings:\nZoom: " + tempZoom + "\nX: " + tempOrgX + "\nY: " + tempOrgY );		// Validate the user's input, and make sure they are ints (rounding them)	if( tempZoom>= 0 && tempZoom <= maxAllowedZoom ) {		orgZoomLevel = Math.round( tempZoom );	} else {		alert( "Fail whale on Z zoom level, start over." );		return false;	}	if( tempOrgX>= 0 && tempOrgX <= Math.pow( 2, maxAllowedZoom )) {		orgX = Math.round( tempOrgX );	} else {		alert( "Fail whale on X origin, start over." );		return false;	}	if( tempOrgY>= 0 && tempOrgY <= Math.pow( 2, maxAllowedZoom )) {		orgY = Math.round( tempOrgY );	} else {		alert( "Fail whale on Y origin, start over." );		return false;	}		// Start off only doing for the 1:1 scale	highestZoomLevel = orgZoomLevel;	lowestZoomLevel = orgZoomLevel;	zoomLevel = highestZoomLevel;	lastZoomLevel = orgZoomLevel;		currentX = orgX;	currentY = orgY;	  		// Determine what WPNI column size it should be scaled up to (sets print2webScaler variable)	//setScalingWPNI( (contentWidth * print2webScaler) );			return true;}function doTheSave(z,x,y) {	// Set the final file name with type extension	// Note, dest already has trailing /	// Note, f_ext auto gets a "." later	var filePath;		if( saveGIF ) {		f_ext = "gif";		filePath = dest + z + tileSetPathSeparator + x + tileSetPathSeparator + y + "." + f_ext;		exportFileToGIF (filePath);	}    if( saveJPEG ) {		f_ext = "jpg";		filePath = dest + z + tileSetPathSeparator + x + tileSetPathSeparator + y + "." + f_ext;		exportFileToJPEG (filePath);	}     if( savePNG ) {		f_ext = "png";		filePath = dest + z + tileSetPathSeparator + x + tileSetPathSeparator + y + "." + f_ext;		exportFileToPNG24 (filePath);	}    if( saveSVG ) {		f_ext = "svg";		filePath = dest + z + tileSetPathSeparator + x + tileSetPathSeparator + y + "." + f_ext;		exportFileToSVG (filePath);	}			//alert( "dest:\n" + dest );	//alert("Save done");}// Can this be removed? Not simple, there is a dependency. But this function is doing more than claimed in name.function setCropArea() {	if (documents.length > 0){			if (doc.layers.length > 0) {			totalLayers = doc.layers.length;						// initilize the boundary			bnd[0] = null;			bnd[2] = null;			bnd[1] = null;			bnd[3] = null;						var firstTime = true;			// now get the boundary for each layer			for( layerCounter = totalLayers-1; layerCounter >= 0;  layerCounter-- ) {					isVisibleLayer = doc.layers[ layerCounter ].visible;				thisLayersObjects = doc.layers[ layerCounter ].pageItems;				// the layer has to be visible and have contents... and the patches layer should be ignored (often extra patches are outside the neatline)				// Problem with type on a path where the path bounds is being reported... even if it goes beyond the neatline and has no path right on it (the type is inside the neatline)				// Or test for path type and if not stroked then ignore?				// This way point and area type would still be counted, even on the type map layer				// Would need to be done in the GetBounds function				// Also need to discount graph type objects since they often fall outside in invisible pieces				if( (isVisibleLayer && thisLayersObjects.length > 0) && (doc.layers[ layerCounter ].name != "Patches") && (doc.layers[ layerCounter ].name != "Type map") ) {					layer_bnd = getBounds(thisLayersObjects);							if( firstTime ) {						// prompt( "first time" );						bnd[0] = layer_bnd[0];						bnd[1] = layer_bnd[1];						bnd[2] = layer_bnd[2];						bnd[3] = layer_bnd[3];						firstTime = false;					} else {						// prompt( "nth time" );						// sprompt( layer_bnd[0], layer_bnd[2], layer_bnd[3] );						if( bnd[0] > layer_bnd[0] ) bnd[0] = layer_bnd[0];						if( bnd[1] < layer_bnd[1] ) bnd[1] = layer_bnd[1];						if( bnd[2] < layer_bnd[2] ) bnd[2] = layer_bnd[2];						if( bnd[3] > layer_bnd[3] ) bnd[3] = layer_bnd[3];						// prompt( bnd[0], bnd[2], bnd[3] );					}				}			}			// prompt( bnd[0], bnd[1], bnd[2] );			W = bnd[2] - bnd[0];			H = bnd[1] - bnd[3];			X = bnd[0];			Y = bnd[1];		// if there is no layers? shouldn't it be objects on that layer?		} else {			doc.rulerOrigin = Array(0, 0);			bnd[0] = 0;			bnd[2] = doc.width;			bnd[1] = doc.height;			bnd[3] = 0;				}			// prompt( bnd[0], bnd[1], bnd[2] );		doc.cropBox = bnd;		doc.cropStyle = CropOptions.Standard;		}}function getBounds(obj) {	var selObj1 = new Array();	var selObj2 = new Array();	var vgb1 = new Array();	var vgb2 = new Array();	var n = obj.length;		if (n>0){					// ignore worst case of (1) type on path or (2) guide items		if( (obj[0].guides == true) ){			// do nothing		} else {			// group items that are masked case			if( (obj[0].typename == 'GroupItem') && obj[0].clipped && (obj[0].pageItems.length > 1) ){				clipObj = obj[0].pathItems[0].geometricBounds;				vgb1 = clipObj;			} else {				selObj1 = obj[0];				vgb1 = selObj1.visibleBounds;			}/*		} else {			vgb1 = new Array;			vgb1[0] = vgb1[1] = vgb1[2] = vgb1[3] = null;*/		}				// loose page items case		if (n > 1) {			for (i=1; i<n; i++) {				selObj2 = obj[i];								// do a test here for the path type (ignore it, break to next object)				/*if( (obj[i].guides) ){					continue; 				}*/												// do a test here for the guides type (ignore it, break to next object)				if( (obj[i].guides == true) ){					// do nothing				} else {					// layer clipping mask case					if( (obj[i].typename == 'PathItem') && (obj[i].clipping) ){						clipObj = obj[i].geometricBounds;						vgb2 = clipObj;						return vgb2;					}														if( (obj[i].typename == 'GroupItem') && obj[i].clipped && (obj[i].pageItems.length > 1) ) {						vgb2 = obj[i].pathItems[0].geometricBounds;					} else {						vgb2 = selObj2.visibleBounds;					}					if( vgb1[0] > vgb2[0] ) vgb1[0] = vgb2[0];					if( vgb1[1] < vgb2[1] ) vgb1[1] = vgb2[1];					if( vgb1[2] < vgb2[2] ) vgb1[2] = vgb2[2];					if( vgb1[3] > vgb2[3] ) vgb1[3] = vgb2[3];				}			}		}	}	return vgb1;}//------------------------//-------- EXPORT FORMATS//------------------------function exportFileToEPS (dest) {	if ( app.documents.length > 0 ) {		var saveOptions = new EPSSaveOptions();		var type = ExportType.JPEG;		var fileSpec = new File(dest);		//Speichern optionen		saveOptions.cmykPostScript = true;		//8 bit Tiff vorschau 		saveOptions.preview = EPSPreview.COLORTIFF;		//Postscript Level 2		saveOptions.postScript = EPSPostScriptLevelEnum.LEVEL2;		//Compatibility with CS2		saveOptions.compatibility = Compatibility.ILLUSTRATOR12;		// Embede the fonts so they rip in web tracker		saveOptions.embedAllFonts = true;		// Now actually save the EPS out		app.activeDocument.saveAs( fileSpec, saveOptions );	}}function exportFileToGIF (dest) {	if ( app.documents.length > 0 ) {		var exportOptions = new ExportOptionsGIF();		var type = ExportType.GIF;		var fileSpec = new File(dest);		exportOptions.antiAliasing = true;		exportOptions.colorDither = ColorDitherMethod.NOREDUCTION;		exportOptions.colorReduction = ColorReductionMethod.SELECTIVE;		exportOptions.transparency = false;			exportOptions.interlaced = false;		exportOptions.webSnap = 0;		exportOptions.horizontalScale = exportScaler;		exportOptions.verticalScale = exportScaler;		//exportOptions.saveAsHTML = true;		// Set to false for CS and CS2		// exportOptions.matte = true;		// ---- This code is commented out because white is the default color		// ==== but if you want a custom matte, you can reinstate it.		//var newRGBColor = new RGBColor();		//newRGBColor.red = 255;		//newRGBColor.green = 255;		//newRGBColor.blue = 255;		//exportOptions.matteColor=newRGBColor;		app.activeDocument.exportFile( fileSpec, type, exportOptions );	}}function exportFileToJPEG (dest) {	if ( app.documents.length > 0 ) {		var exportOptions = new ExportOptionsJPEG();		var type = ExportType.JPEG;		var fileSpec = new File(dest);		exportOptions.antiAliasing = true;		exportOptions.qualitySetting = 70;		exportOptions.horizontalScale = exportScaler;		exportOptions.verticalScale = exportScaler;				// Set to false for CS and CS2		exportOptions.matte = true;		// ---- This code is commented out because white is the default color		// ==== but if you want a custom matte, you can reinstate it.		//var newRGBColor = new RGBColor();		//newRGBColor.red = 255;		//newRGBColor.green = 255;		//newRGBColor.blue = 255;		//exportOptions.matteColor=newRGBColor;		app.activeDocument.exportFile( fileSpec, type, exportOptions );	}}function exportFileToPNG24 (dest) {	if ( app.documents.length > 0 ) {		var exportOptions = new ExportOptionsPNG24();		var type = ExportType.PNG24;		var fileSpec = new File(dest);		exportOptions.antiAliasing = true;		exportOptions.transparency = false;		exportOptions.horizontalScale = exportScaler;		exportOptions.verticalScale = exportScaler;		//exportOptions.saveAsHTML = true;		app.activeDocument.exportFile( fileSpec, type, exportOptions );	}}function exportFileToSVG (dest) {	if ( app.documents.length > 0 ) {		var exportOptions = new ExportOptionsSVG();		var type = ExportType.SVG;		var fileSpec = new File(dest);		exportOptions.embedRasterImages = true;		exportOptions.embedAllFonts = false;		exportOptions.fontSubsetting = SVGFontSubsetting.GLYPHSUSED;		exportOptions.DTD = SVGDTDVersion.SVG1_1;		//exportOptions.sVGTextOnPath = true;		//exportOptions.documentEncoding = SVGDocumentEncoding.ASCII;		//exportOptions.compressed = false;		//exportOptions.coordinatePrecision = 3;				app.activeDocument.exportFile( fileSpec, type, exportOptions );	}}function setFileName() {	// var format_preset = "{FILENAME} ({DATE} - {TIME})";	// var Dateformat = "mm.dd.yy";	// var Dateformat = "mm/dd/yy";	// var Dateformat = "mmddyy";		if( tileSetPathSeparator == "/" ) {		alert( "Use of / in name not supported at this time. Future version might add in storing in nested subfolders. Use a _ instead." );		return false;	}		var error=0;	if (documents.length<1) {	  error++;	  alert("Open a document and then run this script.")	}	if (error < 1) {	  var fileName = new String; 	  fileName = determineFileName();	  return fileName;	}}// TODO: Pick up here// TODO: Still need to determine the full path for setting the File object parameterfunction determineFileName() {  // var docpath = activeDocument.path.fsName;  // var docname = activeDocument.name;  // var content = format.replace(/\{FILENAME\}/,docname);  // var content = format.replace(/\{DATE\}/,PuplicationDate());	  var theDocName = activeDocument.name;  var theDocPath = activeDocument.path;  var theFileExtIndex = theDocName.lastIndexOf(".")  theDocName = theDocName.substr( 0, theFileExtIndex );  theDocName = theDocPath + "/tiles/";  return theDocName;}function makeTiles() {	var MyXO;	var MyXL;	var MyYO;	var MyYL;		var StartX; 	var StartY;		var xTiles;	var yTiles;			var TotalTiles;		// Counters to track which x value and which y value we are on in our image tile grid	var xm;	var ym;		var TileX;	var TileY;		var tempCropBox;		// Determine where to save the file and what name to give it (eg: "myStorySlug_mmddyy" with .jpg or .gif or .eps as specified)	dest = setFileName();		// Make sure we have a valid filepath	if( dest == false ) {		return false;	}	tilesMiled = 0;				// Do the following for each zoom level the user wants	while( zoomLevel >= lowestZoomLevel )	{		StartX = currentX; 		StartY = currentY;				// Make sure we're snapping to the 256 grid		xTiles = Math.round( contentWidth / pixelWidth );		yTiles = Math.round( contentHeight / pixelHeight );				/*		var note = pixelWidth;		// Revisit the print2webScaler to address 255 instead of 256 (-1 width bug)		pixelWidth  = contentWidth / xTiles; 		pixelHeight = contentHeight / yTiles;				if( note != pixelWidth ) {			alert( "pixelWidth " + pixelWidth + " adjusted from " + note );		}		*/					TotalTiles = xTiles * yTiles;  //<-- calculate the total number of tiles				// Counters to track which x value and which y value we are on in our image tile grid		xm = 0;		ym = 0;				TileX = StartX; //<-- Set out first Google X value - later used in file name		TileY = StartY; //<-- Set out first Google Y value - later used in file name				// Cut 'em up		// For each tile we need to make, we repeat each step in this loop		for (n=1; n<TotalTiles+1; n++)		{            			// We cut up tiles column by column			// I.E. we cut up all the tiles for a given x value before moving on to the next x value.			// We do this by checking if the y value we are on is the last tile in a column 			// We compare our y counter to our total y number of Tiles, if they are the same is we do the following			if( (parseInt(ym, 10) * -1) == parseInt(yTiles, 10) )			{   				xm += 1; //<-- Up the x value by 1, i.e. we move over to the next column   				ym = 0;  //<-- Reset the y value to 0 so we start back at the top of our new column				TileX += 1; //<-- Increase our Google X value for our file name 				TileY = StartY;  //We reset our Google Y value for out file name everytime we change columns			}						// Based on our our TileWidth and TileHeight and the column we are on we determine our selection origin and area values     			MyXO = (xm*pixelWidth);			MyXL = (xm*pixelWidth) + pixelWidth;			MyYO = (ym*pixelHeight);			MyYL = (ym*pixelHeight) - pixelHeight;                							//try {				// TODO				//currentDocument.crop(Array(MyXO, MyYO, MyXL, MyYL));								//alert( "Values are:\nMyXO: " + MyXO + "\nMyXL: " + MyXL + "\nMyYO: "+ MyYO + "\nMyYL: " + MyYL );								tempCropBox = [ bnd[0] + MyXO, bnd[1] + MyYO, bnd[0] + MyXL, bnd[1] + MyYL];				doc.cropBox = tempCropBox;			/*}			catch (e)			{				alert("xm: " + xm + ", ym: " + ym + ", MyXO: " + MyXO + ", MyYO: " + MyYO + ", MyXL: " + MyXL + ", MyYL: " + MyYL + ", XTiles: " + xTiles + ", YTiles: " + yTiles + "ym == yTiles?: " + (ym == yTiles));			}*/								// Do the save			doTheSave( zoomLevel, TileX, TileY );						//Advance Y counter for next image			ym -= 1;						//Advance Google Y value for next image name			TileY += 1;						tilesMiled++;		}		//revertToLastSnapshot(); 		lastZoomLevel = zoomLevel;		zoomLevel--;	}	// Leave the document as we opened it	// TODO: set back to orig crop		return true;}init();